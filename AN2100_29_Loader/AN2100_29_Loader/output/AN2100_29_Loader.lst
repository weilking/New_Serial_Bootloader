FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.3.2710
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#897 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.21
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; The following equate is required for proper operation. Reseting its value
                                        (0068) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                        (0069) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                        (0070) ; and PLL_Lock must take place within user code. See the family data sheet for
                                        (0071) ; the requirements of starting the ECO and PLL lock mode.
                                        (0072) ;
                                        (0073) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                        (0074) ;                invoking main
                                        (0075) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                        (0076) ;               the time code in main starts executing.
                                        (0077) ;
                                        (0078) WAIT_FOR_32K:                    equ 1
                                        (0079) 
                                        (0080) 
                                        (0081) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0082) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0083) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0084) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0085) ; bytes on the stack which are otherwise required for the return address. If
                                        (0086) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0087) ; release, the C compiler automatically places an infinite loop at the end
                                        (0088) ; of main, rather than a return instruction.)
                                        (0089) ;
                                        (0090) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0091) 
                                        (0092) 
                                        (0093) ;-----------------------------------------------------------------------------
                                        (0094) ; Interrupt Vector Table
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;
                                        (0097) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0098) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0099) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0100) ; vector jump targets are modified automatically according to the user
                                        (0101) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0102) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0103) ; configuration files. If you need to hard code a vector, update the
                                        (0104) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0105) ; of this file.
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) 
                                        (0108)     AREA TOP (ROM, ABS, CON)
                                        (0109) 
                                        (0110)     org   0                        ;Reset Interrupt Vector
0000: 7D 74 00 LJMP  0x7400             (0111)     ljmp   __Boot_Start                  ;First instruction executed following a Reset
                                        (0112) 
                                        (0113)     org   04h                      ;Supply Monitor Interrupt Vector
0004: 30       HALT                     (0114)     halt                           ;Stop execution if power falls too low
                                        (0115) 
                                        (0116)     org   08h                      ;Analog Column 0 Interrupt Vector
0008: 7D 00 68 LJMP  0x0068             (0117)     ljmp  0x0068
000B: 7E       RETI                     (0118)     reti
                                        (0119) 
                                        (0120)     org   0Ch                      ;Analog Column 1 Interrupt Vector
000C: 7D 00 6C LJMP  0x006C             (0121)     ljmp  0x006C
000F: 7E       RETI                     (0122)     reti
                                        (0123) 
                                        (0124)     org   10h                      ;Analog Column 2 Interrupt Vector
0010: 7D 00 70 LJMP  0x0070             (0125)     ljmp  0x0070
0013: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   14h                      ;Analog Column 3 Interrupt Vector
0014: 7D 00 74 LJMP  0x0074             (0129)     ljmp  0x0074
0017: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   18h                      ;VC3 Interrupt Vector
0018: 7D 00 78 LJMP  0x0078             (0133)     ljmp  0x0078
001B: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   1Ch                      ;GPIO Interrupt Vector
001C: 7D 00 7C LJMP  0x007C             (0137)     ljmp  0x007C
001F: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 00 80 LJMP  0x0080             (0141)     ljmp  0x0080
0023: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
0024: 7D 00 84 LJMP  0x0084             (0145)     ljmp  0x0084
0027: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
0028: 7D 00 88 LJMP  0x0088             (0149)     ljmp  0x0088
002B: 7E       RETI                     (0150)     reti
                                        (0151) 
                                        (0152)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 00 8C LJMP  0x008C             (0153)     ljmp  0x008C
002F: 7E       RETI                     (0154)     reti
                                        (0155) 
                                        (0156)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
0030: 7D 00 90 LJMP  0x0090             (0157)     ljmp  0x0090
0033: 7E       RETI                     (0158)     reti
                                        (0159) 
                                        (0160)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
0034: 7D 00 94 LJMP  0x0094             (0161)     ljmp  0x0094
0037: 7E       RETI                     (0162)     reti
                                        (0163) 
                                        (0164)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
0038: 7D 00 98 LJMP  0x0098             (0165)     ljmp  0x0098
003B: 7E       RETI                     (0166)     reti
                                        (0167) 
                                        (0168)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
003C: 7D 00 9C LJMP  0x009C             (0169)     ljmp  0x009C
003F: 7E       RETI                     (0170)     reti
                                        (0171) 
                                        (0172)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
                                        (0173)     // call	void_handler
0040: 7E       RETI                     (0174)     reti
                                        (0175) 
                                        (0176)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
                                        (0177)     // call	void_handler
0044: 7E       RETI                     (0178)     reti
                                        (0179) 
                                        (0180)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                        (0181)     // call	void_handler
0048: 7E       RETI                     (0182)     reti
                                        (0183) 
                                        (0184)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
                                        (0185)     // call	void_handler
004C: 7E       RETI                     (0186)     reti
                                        (0187) 
                                        (0188)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                        (0189)     // call	void_handler
0050: 7E       RETI                     (0190)     reti
                                        (0191) 
                                        (0192)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
                                        (0193)     // call	void_handler
0054: 7E       RETI                     (0194)     reti
                                        (0195) 
                                        (0196)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                        (0197)     // call	void_handler
0058: 7E       RETI                     (0198)     reti
                                        (0199) 
                                        (0200)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                        (0201)     // call	void_handler
005C: 7E       RETI                     (0202)     reti
                                        (0203) 
                                        (0204)     org   60h                      ;PSoC I2C Interrupt Vector
                                        (0205)     // call	void_handler
0060: 7E       RETI                     (0206)     reti
                                        (0207) 
                                        (0208)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0209)     // call	void_handler
0064: 7E       RETI                     (0210)     reti
                                        (0211) 
                                        (0212) /////////////////////////////////////////////////
                                        (0213) // New Relocatable Vector Table
                                        (0214) /////////////////////////////////////////////////
                                        (0215) 
                                        (0216)     org   68h                      ;Analog Column 0 Interrupt Vector
                                        (0217)     // call	void_handler
0068: 7E       RETI                     (0218)     reti
                                        (0219) 
                                        (0220)     org   6Ch                      ;Analog Column 1 Interrupt Vector
                                        (0221)     // call	void_handler
006C: 7E       RETI                     (0222)     reti
                                        (0223) 
                                        (0224)     org   70h                      ;Analog Column 2 Interrupt Vector
                                        (0225)     // call	void_handler
0070: 7E       RETI                     (0226)     reti
                                        (0227) 
                                        (0228)     org   74h                      ;Analog Column 3 Interrupt Vector
                                        (0229)     // call	void_handler
0074: 7E       RETI                     (0230)     reti
                                        (0231) 
                                        (0232)     org   78h                      ;VC3 Interrupt Vector
                                        (0233)     // call	void_handler
0078: 7E       RETI                     (0234)     reti
                                        (0235) 
                                        (0236)     org   7Ch                      ;GPIO Interrupt Vector
                                        (0237)     // call	void_handler
007C: 7E       RETI                     (0238)     reti
                                        (0239) 
                                        (0240)     org   80h                      ;PSoC Block DBB00 Interrupt Vector
                                        (0241)     // call	void_handler
0080: 7E       RETI                     (0242)     reti
                                        (0243) 
                                        (0244)     org   84h                      ;PSoC Block DBB01 Interrupt Vector
                                        (0245)     // call	void_handler
0084: 7E       RETI                     (0246)     reti
                                        (0247) 
                                        (0248)     org   88h                      ;PSoC Block DCB02 Interrupt Vector
                                        (0249)     // call	void_handler
0088: 7E       RETI                     (0250)     reti
                                        (0251) 
                                        (0252)     org   8Ch                      ;PSoC Block DCB03 Interrupt Vector
                                        (0253)     // call	void_handler
008C: 7E       RETI                     (0254)     reti
                                        (0255) 
                                        (0256)     org   90h                      ;PSoC Block DBB10 Interrupt Vector
                                        (0257)     // call	void_handler
0090: 7E       RETI                     (0258)     reti
                                        (0259) 
                                        (0260)     org   94h                      ;PSoC Block DBB11 Interrupt Vector
                                        (0261)     // call	void_handler
0094: 7E       RETI                     (0262)     reti
                                        (0263) 
                                        (0264)     org   98h                      ;PSoC Block DCB12 Interrupt Vector
                                        (0265)     // call	void_handler
0098: 7E       RETI                     (0266)     reti
                                        (0267) 
                                        (0268)     org   9Ch                      ;PSoC Block DCB13 Interrupt Vector
                                        (0269)     // call	void_handler
009C: 7E       RETI                     (0270)     reti
00A6: 71 10    OR    F,0x10             
                                        (0271) 
                                        (0272) ;-----------------------------------------------------------------------------
                                        (0273) ;  Start of Execution.
                                        (0274) ;-----------------------------------------------------------------------------
                                        (0275) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0276) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0277) ;
                                        (0278)   org A0h
                                        (0279) __Boot_Check_Program:
                                        (0280)     db 2,3,4,5,6,7	// Control bytes sequence for BootLoader based Projects
                                        (0281) 
                                        (0282) 
                                        (0283) __Start:
                                        (0284) 
                                        (0285)     ; initialize SMP values for voltage stabilization, if required,
                                        (0286)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0287)     ; least for now. 
                                        (0288)     ;
                                        (0289)     M8C_SetBank1
00A8: 62 FA 00 MOV   REG[0xFA],0x0      (0290)     mov reg[0FAh], 0				;Reset flash location
00AB: 62 E3 87 MOV   REG[0xE3],0x87     (0291)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
00AE: 70 EF    AND   F,0xEF             
                                        (0292)     M8C_SetBank0
                                        (0293) 
                                        (0294)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
00B0: 50 20    MOV   A,0x20             (0295)     mov   A, 20h
00B2: 28       ROMX                     (0296)     romx
00B3: 50 40    MOV   A,0x40             (0297)     mov   A, 40h
00B5: 28       ROMX                     (0298)     romx
00B6: 50 60    MOV   A,0x60             (0299)     mov   A, 60h
00B8: 28       ROMX                     (0300)     romx
00B9: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0301)     ; %45%20%46%46% End workaround
                                        (0302) 
                                        (0303) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0304) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0305)     M8C_EnableWatchDog
                                        (0306) ENDIF
                                        (0307) 
                                        (0308) IF ( SELECT_32K )
                                        (0309)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                        (0310) ELSE
00BC: 41 FE FB AND   REG[0xFE],0xFB     (0311)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0312) ENDIF
                                        (0313) 
                                        (0314)     ;---------------------------
                                        (0315)     ; Set up the Temporary stack
                                        (0316)     ;---------------------------
                                        (0317)     ; A temporary stack is set up for the SSC instructions.
                                        (0318)     ; The real stack start will be assigned later.
                                        (0319)     ;
                                        (0320) _stack_start:          equ 80h
00BF: 50 80    MOV   A,0x80             (0321)     mov   A, _stack_start          ; Set top of stack to end of used RAM
00C1: 4E       SWAP  SP,A               (0322)     swap  SP, A                    ; This is only temporary if going to LMM
00C2: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0323) 
                                        (0324)     ;-----------------------------------------------
                                        (0325)     ; Set Power-related Trim & the AGND Bypass bit.
                                        (0326)     ;-----------------------------------------------
                                        (0327) M8C_ClearWDTAndSleep ; Clear WDT before enabling it.
                                        (0328) 
                                        (0329) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0330)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0331)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0332)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0333)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0334)   IF ( AGND_BYPASS )
                                        (0335)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0336)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0337)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0338)     ; value using the proper trim values.
                                        (0339)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0340)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0341)   ENDIF
                                        (0342)  ENDIF
                                        (0343) ENDIF ; 5.0 V Operation
                                        (0344) 
                                        (0345) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0346)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0347)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0348)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0349)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0350)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0351)  ENDIF
                                        (0352) ENDIF ; 3.3 Volt Operation
                                        (0353) 
00C5: 55 F8 00 MOV   [0xF8],0x0         (0354)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00C8: 55 F9 00 MOV   [0xF9],0x0         (0355)     mov  [bSSC_KEYSP], 0
00CB: 71 10    OR    F,0x10             
                                        (0356) 
                                        (0357)     ;---------------------------------------
                                        (0358)     ; Initialize Crystal Oscillator and PLL
                                        (0359)     ;---------------------------------------
                                        (0360) 
                                        (0361) IF ( SELECT_32K & WAIT_FOR_32K )
                                        (0362)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                        (0363)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                        (0364)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                        (0365)     ; the ECO to stabilize.
                                        (0366)     ;
                                        (0367)     M8C_SetBank1
                                        (0368)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                        (0369)     M8C_SetBank0
                                        (0370)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                        (0371)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                        (0372)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                        (0373) .WaitFor1s:
                                        (0374)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                        (0375)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                        (0376)                                           ;   since interrupts are not globally enabled
                                        (0377) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                        (0378)     ; Either no ECO, or waiting for stable clock is to be done in main
                                        (0379)     M8C_SetBank1
00CD: 62 E0 02 MOV   REG[0xE0],0x2      (0380)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
00D0: 70 EF    AND   F,0xEF             
00D2: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0381)     M8C_SetBank0
                                        (0382)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0383) 
                                        (0384) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                        (0385) 
                                        (0386) IF ( PLL_MODE )
                                        (0387)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                        (0388)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                        (0389)     ;
                                        (0390)     M8C_SetBank1
                                        (0391)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                        (0392)     M8C_SetBank0
                                        (0393)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                        (0394)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                        (0395) 
                                        (0396) .WaitFor16ms:
                                        (0397)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0398)     jz   .WaitFor16ms
                                        (0399)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
                                        (0400)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
                                        (0401)     M8C_SetBank0
                                        (0402) 
                                        (0403) IF      ( WAIT_FOR_32K )
                                        (0404) ELSE ; !( WAIT_FOR_32K )
                                        (0405)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                        (0406)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                        (0407) ENDIF ;(WAIT_FOR_32K)
                                        (0408) ENDIF ;(PLL_MODE)
                                        (0409) 
                                        (0410) 	;-------------------------------------------------------
                                        (0411)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0412)     ;-------------------------------------------------------
                                        (0413) 
                                        (0414)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0415) 
                                        (0416) IF (SYSCLK_SOURCE)
                                        (0417)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0418) ENDIF
                                        (0419)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0420) 
                                        (0421)     ;------------------------
                                        (0422)     ; Close CT leakage path.
                                        (0423)     ;------------------------
00D5: 62 71 05 MOV   REG[0x71],0x5      (0424)     mov   reg[ACB00CR0], 05h
00D8: 62 75 05 MOV   REG[0x75],0x5      (0425)     mov   reg[ACB01CR0], 05h
00DB: 62 79 05 MOV   REG[0x79],0x5      (0426)     mov   reg[ACB02CR0], 05h
00DE: 62 7D 05 MOV   REG[0x7D],0x5      (0427)     mov   reg[ACB03CR0], 05h
00E1: 62 D1 07 MOV   REG[0xD1],0x7      
                                        (0428) 
                                        (0429) 
                                        (0430) IF	(TOOLCHAIN & HITECH)
                                        (0431)     ;---------------------------------------------
                                        (0432)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0433)     ;---------------------------------------------
                                        (0434) 	global		__Lstackps
                                        (0435) 	mov     a,low __Lstackps
                                        (0436) 	swap    a,sp
                                        (0437) 
                                        (0438) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0439)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0440)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0441)     RAM_SETPAGE_CUR 0
                                        (0442)     RAM_SETPAGE_MVW 0
                                        (0443)     RAM_SETPAGE_MVR 0
                                        (0444)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0445)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0446)     ELSE
                                        (0447)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0448)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0449) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0450) ELSE
                                        (0451)     ;---------------------------------------------
                                        (0452)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0453)     ;---------------------------------------------
                                        (0454) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0455)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00E4: 50 00    MOV   A,0x0              (0456)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00E6: 4E       SWAP  SP,A               (0457)     swap  A, SP
00E7: 62 D3 07 MOV   REG[0xD3],0x7      
00EA: 62 D0 00 MOV   REG[0xD0],0x0      
00ED: 62 D5 00 MOV   REG[0xD5],0x0      
00F0: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0458)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0459)     RAM_SETPAGE_CUR 0
                                        (0460)     RAM_SETPAGE_MVW 0
                                        (0461)     RAM_SETPAGE_MVR 0
                                        (0462) 
                                        (0463)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00F3: 71 C0    OR    F,0xC0             (0464)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0465)   ELSE
                                        (0466)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0467)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0468) ELSE
                                        (0469)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0470)     swap  SP, A
                                        (0471) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0472) ENDIF ;	TOOLCHAIN
                                        (0473) 
                                        (0474)     ;-------------------------
                                        (0475)     ; Load Base Configuration
                                        (0476)     ;-------------------------
                                        (0477)     ; Load global parameter settings and load the user modules in the
                                        (0478)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0479)     ; to minimize start up time; (2) We may still need to play with the
                                        (0480)     ; Sleep Timer.
                                        (0481)     ;
00F5: 7C 03 9B LCALL 0x039B             (0482)     lcall LoadConfigInit
                                        (0483) 
                                        (0484)     ;-----------------------------------
                                        (0485)     ; Initialize C Run-Time Environment
                                        (0486)     ;-----------------------------------
                                        (0487) IF ( C_LANGUAGE_SUPPORT )
                                        (0488) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                        (0489)     mov  A,0                           ; clear the 'bss' segment to zero
                                        (0490)     mov  [__r0],<__bss_start
                                        (0491) BssLoop:
                                        (0492)     cmp  [__r0],<__bss_end
                                        (0493)     jz   BssDone
                                        (0494)     mvi  [__r0],A
                                        (0495)     jmp  BssLoop
                                        (0496) BssDone:
                                        (0497)     mov  A,>__idata_start              ; copy idata to data segment
                                        (0498)     mov  X,<__idata_start
                                        (0499)     mov  [__r0],<__data_start
                                        (0500) IDataLoop:
                                        (0501)     cmp  [__r0],<__data_end
                                        (0502)     jz   C_RTE_Done
                                        (0503)     push A
                                        (0504)     romx
                                        (0505)     mvi  [__r0],A
                                        (0506)     pop  A
                                        (0507)     inc  X
                                        (0508)     adc  A,0
                                        (0509)     jmp  IDataLoop
                                        (0510) 
                                        (0511) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0512) 
                                        (0513) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00F8: 62 D0 00 MOV   REG[0xD0],0x0      (0514)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0515)                                        ; to use the Virtual Register page.
                                        (0516) 
                                        (0517)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0518)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0519)     ; text segment and may have been relocated by the Code Compressor.
                                        (0520)     ;
00FB: 50 02    MOV   A,0x2              (0521)     mov   A, >__pXIData                ; Get the address of the flash
00FD: 57 94    MOV   X,0x94             (0522)     mov   X, <__pXIData                ;   pointer to the xidata area.
00FF: 08       PUSH  A                  (0523)     push  A
0100: 28       ROMX                     (0524)     romx                               ; get the MSB of xidata's address
0101: 53 06    MOV   [__r0],A           (0525)     mov   [__r0], A
0103: 18       POP   A                  (0526)     pop   A
0104: 75       INC   X                  (0527)     inc   X
0105: 09 00    ADC   A,0x0              (0528)     adc   A, 0
0107: 28       ROMX                     (0529)     romx                               ; get the LSB of xidata's address
0108: 4B       SWAP  A,X                (0530)     swap  A, X
0109: 51 06    MOV   A,[__r0]           (0531)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0532)                                        ;   XIData structure list in flash
010B: 80 04    JMP   0x0110             (0533)     jmp   .AccessStruct
                                        (0534) 
                                        (0535)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0536)     ; values of C variables. Each structure contains 3 member elements.
                                        (0537)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0538)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0539)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0540)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0541)     ; value in the second member element, an unsigned byte:
                                        (0542)     ; (1) If the value of the second element is non-zero, it represents
                                        (0543)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0544)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0545)     ; the bytes are copied to the block of RAM.
                                        (0546)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0547)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0548)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0549) 
                                        (0550) .AccessNextStructLoop:
010D: 75       INC   X                  (0551)     inc   X                            ; pXIData++
010E: 09 00    ADC   A,0x0              (0552)     adc   A, 0
0110: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0553) .AccessStruct:                         ; Entry point for first block
                                        (0554)     ;
                                        (0555)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0556)     ;
                                        (0557)     M8C_ClearWDT                       ; Clear the watchdog for long inits
0113: 08       PUSH  A                  (0558)     push  A
0114: 28       ROMX                     (0559)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
0115: 60 D5    MOV   REG[0xD5],A        (0560)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
0117: 74       INC   A                  (0561)     inc   A                            ; End of Struct List? (MSB==0xFF?)
0118: A0 4B    JZ    0x0164             (0562)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
011A: 18       POP   A                  (0563)     pop   A                            ; restore pXIData to [A,X]
011B: 75       INC   X                  (0564)     inc   X                            ; pXIData++
011C: 09 00    ADC   A,0x0              (0565)     adc   A, 0
011E: 08       PUSH  A                  (0566)     push  A
011F: 28       ROMX                     (0567)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
0120: 53 06    MOV   [__r0],A           (0568)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
0122: 18       POP   A                  (0569)     pop   A                            ; restore pXIData to [A,X]
0123: 75       INC   X                  (0570)     inc   X                            ; pXIData++ (point to size)
0124: 09 00    ADC   A,0x0              (0571)     adc   A, 0
0126: 08       PUSH  A                  (0572)     push  A
0127: 28       ROMX                     (0573)     romx                               ; Get the size (CPU.A <- *pXIData)
0128: A0 1C    JZ    0x0145             (0574)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
012A: 53 05    MOV   [__r1],A           (0575)     mov   [__r1], A                    ;             else downcount in __r1
012C: 18       POP   A                  (0576)     pop   A                            ; restore pXIData to [A,X]
                                        (0577) 
                                        (0578) .CopyNextByteLoop:
                                        (0579)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0580)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0581)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0582)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0583)     ;
012D: 75       INC   X                  (0584)     inc   X                            ; pXIData++ (point to next data byte)
012E: 09 00    ADC   A,0x0              (0585)     adc   A, 0
0130: 08       PUSH  A                  (0586)     push  A
0131: 28       ROMX                     (0587)     romx                               ; Get the data value (CPU.A <- *pXIData)
0132: 3F 06    MVI   [__r0],A           (0588)     mvi   [__r0], A                    ; Transfer the data to RAM
0134: 47 06 FF TST   [__r0],0xFF        (0589)     tst   [__r0], 0xff                 ; Check for page crossing
0137: B0 06    JNZ   0x013E             (0590)     jnz   .CopyLoopTail                ;   No crossing, keep going
0139: 5D D5    MOV   A,REG[0xD5]        (0591)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
013B: 74       INC   A                  (0592)     inc   A
013C: 60 D5    MOV   REG[0xD5],A        (0593)     mov   reg[ MVW_PP], A
                                        (0594) .CopyLoopTail:
013E: 18       POP   A                  (0595)     pop   A                            ; restore pXIData to [A,X]
013F: 7A 05    DEC   [__r1]             (0596)     dec   [__r1]                       ; End of this array in flash?
0141: BF EB    JNZ   0x012D             (0597)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
0143: 8F C9    JMP   0x010D             (0598)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0599) 
                                        (0600) .ClearRAMBlockToZero:
0145: 18       POP   A                  (0601)     pop   A                            ; restore pXIData to [A,X]
0146: 75       INC   X                  (0602)     inc   X                            ; pXIData++ (point to next data byte)
0147: 09 00    ADC   A,0x0              (0603)     adc   A, 0
0149: 08       PUSH  A                  (0604)     push  A
014A: 28       ROMX                     (0605)     romx                               ; Get the run length (CPU.A <- *pXIData)
014B: 53 05    MOV   [__r1],A           (0606)     mov   [__r1], A                    ; Initialize downcounter
014D: 50 00    MOV   A,0x0              (0607)     mov   A, 0                         ; Initialize source data
                                        (0608) 
                                        (0609) .ClearRAMBlockLoop:
                                        (0610)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0611)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0612)     ;
014F: 3F 06    MVI   [__r0],A           (0613)     mvi   [__r0], A                    ; Clear a byte
0151: 47 06 FF TST   [__r0],0xFF        (0614)     tst   [__r0], 0xff                 ; Check for page crossing
0154: B0 08    JNZ   0x015D             (0615)     jnz   .ClearLoopTail               ;   No crossing, keep going
0156: 5D D5    MOV   A,REG[0xD5]        (0616)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0158: 74       INC   A                  (0617)     inc   A
0159: 60 D5    MOV   REG[0xD5],A        (0618)     mov   reg[ MVW_PP], A
015B: 50 00    MOV   A,0x0              (0619)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0620) .ClearLoopTail:
015D: 7A 05    DEC   [__r1]             (0621)     dec   [__r1]                       ; Was this the last byte?
015F: BF EF    JNZ   0x014F             (0622)     jnz   .ClearRAMBlockLoop           ;   No,  continue
0161: 18       POP   A                  (0623)     pop   A                            ;   Yes, restore pXIData to [A,X] and
0162: 8F AA    JMP   0x010D             (0624)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0625) 
                                        (0626) .C_RTE_WrapUp:
0164: 18       POP   A                  (0627)     pop   A                            ; balance stack
0165: 71 10    OR    F,0x10             
0167: 70 EF    AND   F,0xEF             
                                        (0628) 
                                        (0629) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0630) 
                                        (0631) C_RTE_Done:
                                        (0632) 
                                        (0633) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0634) 
                                        (0635)     ;-------------------------------
                                        (0636)     ; Voltage Stabilization for SMP
                                        (0637)     ;-------------------------------
                                        (0638) 
                                        (0639) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0640) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0641)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0642)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0643)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0644)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0645)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0646)     M8C_SetBank1
                                        (0647)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0648)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0649)     M8C_SetBank0
                                        (0650)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0651)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0652) .WaitFor2ms:
                                        (0653)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0654)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0655) ENDIF ; SMP is operational
                                        (0656) ENDIF ; 5.0V Operation
                                        (0657) 
                                        (0658)     ;-------------------------------
                                        (0659)     ; Set Power-On Reset (POR) Level
                                        (0660)     ;-------------------------------
                                        (0661) 
                                        (0662)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0663)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0664)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. These
                                        (0665)     ;  values should not be changed from the settings here. Failure to follow this instruction could 
                                        (0666)     ;  lead to corruption of PSoC flash.
                                        (0667) 
                                        (0668)     M8C_SetBank1
                                        (0669) 
                                        (0670) IF (POWER_SETTING & POWER_SET_5V0)          ; 5.0V Operation?
                                        (0671)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)    ; and Slow Mode?
                                        (0672)  ELSE                                       ;    No, fast mode
                                        (0673)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz ) ;    As fast as 24MHz?
                                        (0674)                                             ;       no, set midpoint POR in user code, if desired
                                        (0675)   ELSE ; 24HMz                              ;
                                        (0676)     or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
                                        (0677)   ENDIF ; 24MHz
                                        (0678)  ENDIF ; Slow Mode
                                        (0679) ENDIF ; 5.0V Operation
                                        (0680) 
                                        (0681)     M8C_SetBank0
                                        (0682) 
                                        (0683)     ;----------------------------
                                        (0684)     ; Wrap up and invoke "main"
                                        (0685)     ;----------------------------
                                        (0686) 
                                        (0687)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0688)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0689)     ;
0169: 62 E0 00 MOV   REG[0xE0],0x0      (0690)     mov  reg[INT_MSK0],0
016C: 71 10    OR    F,0x10             
                                        (0691) 
                                        (0692)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0693)     ; And put decimator in full mode so it does not consume too much current.
                                        (0694)     ;
                                        (0695)     M8C_SetBank1
016E: 62 E0 02 MOV   REG[0xE0],0x2      (0696)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
0171: 43 E7 80 OR    REG[0xE7],0x80     (0697)     or   reg[DEC_CR2],80h                    ; Put decimator in full mode
0174: 70 EF    AND   F,0xEF             
                                        (0698)     M8C_SetBank0
                                        (0699) 
                                        (0700)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0701)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0702)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0703)     ;
0176: 62 E2 00 MOV   REG[0xE2],0x0      (0704)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0705)                                    ; have been set during the boot process.
                                        (0706) IF	(TOOLCHAIN & HITECH)
                                        (0707) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0708) ELSE
                                        (0709) IF ENABLE_LJMP_TO_MAIN
                                        (0710)     ljmp  _main                    ; goto main (no return)
                                        (0711) ELSE
0179: 7C 03 FD LCALL __text_start|_main|_main(0712)     lcall _main                    ; call main
                                        (0713) .Exit:
017C: 8F FF    JMP   0x017C             (0714)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0715) ENDIF
                                        (0716) ENDIF ; TOOLCHAIN
                                        (0717) 
                                        (0718)     ;---------------------------------
                                        (0719)     ; Library Access to Global Parms
                                        (0720)     ;---------------------------------
                                        (0721)     ;
                                        (0722)  bGetPowerSetting:
                                        (0723) _bGetPowerSetting:
                                        (0724)     ; Returns value of POWER_SETTING in the A register.
                                        (0725)     ; No inputs. No Side Effects.
                                        (0726)     ;
017E: 50 10    MOV   A,0x10             (0727)     mov   A, POWER_SETTING
0180: 7F       RET                      (0728)     ret
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.3.2710
0296: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) include "m8c.inc"
                                        (0004) ;  Personalization tables 
                                        (0005) export LoadConfigTBL_AN2100_29_Loader_Bank1
                                        (0006) export LoadConfigTBL_AN2100_29_Loader_Bank0
                                        (0007) export LoadConfigTBL_AN2100_29_Loader_Ordered
                                        (0008) AREA lit(rom, rel)
                                        (0009) LoadConfigTBL_AN2100_29_Loader_Bank0:
                                        (0010) ;  Global Register values Bank 0
                                        (0011) 	db		60h, 28h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0012) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0013) 	db		63h, 05h		; AnalogReferenceControl register (ARF_CR)
                                        (0014) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0015) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                        (0016) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                        (0017) 	db		d6h, 00h		; I2CConfig register (I2C_CFG)
                                        (0018) 	db		b0h, 00h		; Row_0_InputMux register (RDI0RI)
                                        (0019) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0020) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0021) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0022) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0023) 	db		b5h, 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0024) 	db		b6h, 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0025) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
                                        (0026) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
                                        (0027) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
                                        (0028) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
                                        (0029) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
                                        (0030) 	db		bdh, 00h		; Row_1_OutputDrive_0 register (RDI1SRO0)
                                        (0031) 	db		beh, 00h		; Row_1_OutputDrive_1 register (RDI1SRO1)
                                        (0032) 	db		c0h, 00h		; Row_2_InputMux register (RDI2RI)
                                        (0033) 	db		c1h, 00h		; Row_2_InputSync register (RDI2SYN)
                                        (0034) 	db		c2h, 20h		; Row_2_LogicInputAMux register (RDI2IS)
                                        (0035) 	db		c3h, 33h		; Row_2_LogicSelect_0 register (RDI2LT0)
                                        (0036) 	db		c4h, 33h		; Row_2_LogicSelect_1 register (RDI3LT1)
                                        (0037) 	db		c5h, 00h		; Row_2_OutputDrive_0 register (RDI2SRO0)
                                        (0038) 	db		c6h, 00h		; Row_2_OutputDrive_1 register (RDI2SRO1)
                                        (0039) 	db		c8h, 55h		; Row_3_InputMux register (RDI3RI)
                                        (0040) 	db		c9h, 00h		; Row_3_InputSync register (RDI3SYN)
                                        (0041) 	db		cah, 30h		; Row_3_LogicInputAMux register (RDI3IS)
                                        (0042) 	db		cbh, 33h		; Row_3_LogicSelect_0 register (RDI3LT0)
                                        (0043) 	db		cch, 33h		; Row_3_LogicSelect_1 register (RDI3LT1)
                                        (0044) 	db		cdh, 00h		; Row_3_OutputDrive_0 register (RDI3SRO0)
                                        (0045) 	db		ceh, 00h		; Row_3_OutputDrive_1 register (RDI3SRO1)
                                        (0046) 	db		6ch, 00h		; TMP_DR0 register (TMP_DR0)
                                        (0047) 	db		6dh, 00h		; TMP_DR1 register (TMP_DR1)
                                        (0048) 	db		6eh, 00h		; TMP_DR2 register (TMP_DR2)
                                        (0049) 	db		6fh, 00h		; TMP_DR3 register (TMP_DR3)
                                        (0050) 	db		ffh
                                        (0051) LoadConfigTBL_AN2100_29_Loader_Bank1:
                                        (0052) ;  Global Register values Bank 1
                                        (0053) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0054) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0055) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0056) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0057) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0058) 	db		68h, 33h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0059) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0060) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0061) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0062) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0063) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0064) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0065) 	db		e1h, f0h		; OscillatorControl_1 register (OSC_CR1)
                                        (0066) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0067) 	db		dfh, 00h		; OscillatorControl_3 register (OSC_CR3)
                                        (0068) 	db		deh, 00h		; OscillatorControl_4 register (OSC_CR4)
                                        (0069) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0070) 	db		e7h, 00h		; Type2Decimator_Control register (DEC_CR2)
                                        (0071) 	db		ffh
                                        (0072) AREA psoc_config(rom, rel)
                                        (0073) LoadConfigTBL_AN2100_29_Loader_Ordered:
                                        (0074) ;  Ordered Global Register values
                                        (0075) 	M8C_SetBank0
0298: 62 00 00 MOV   REG[0x0],0x0       (0076) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
029B: 71 10    OR    F,0x10             
                                        (0077) 	M8C_SetBank1
029D: 62 00 00 MOV   REG[0x0],0x0       (0078) 	mov	reg[00h], 00h		; Port_0_DriveMode_0 register (PRT0DM0)
02A0: 62 01 FF MOV   REG[0x1],0xFF      (0079) 	mov	reg[01h], ffh		; Port_0_DriveMode_1 register (PRT0DM1)
02A3: 70 EF    AND   F,0xEF             
                                        (0080) 	M8C_SetBank0
02A5: 62 03 FF MOV   REG[0x3],0xFF      (0081) 	mov	reg[03h], ffh		; Port_0_DriveMode_2 register (PRT0DM2)
02A8: 62 02 00 MOV   REG[0x2],0x0       (0082) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
02AB: 71 10    OR    F,0x10             
                                        (0083) 	M8C_SetBank1
02AD: 62 02 00 MOV   REG[0x2],0x0       (0084) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
02B0: 62 03 00 MOV   REG[0x3],0x0       (0085) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
02B3: 70 EF    AND   F,0xEF             
                                        (0086) 	M8C_SetBank0
02B5: 62 01 00 MOV   REG[0x1],0x0       (0087) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
02B8: 62 04 00 MOV   REG[0x4],0x0       (0088) 	mov	reg[04h], 00h		; Port_1_Data register (PRT1DR)
02BB: 71 10    OR    F,0x10             
                                        (0089) 	M8C_SetBank1
02BD: 62 04 80 MOV   REG[0x4],0x80      (0090) 	mov	reg[04h], 80h		; Port_1_DriveMode_0 register (PRT1DM0)
02C0: 62 05 7F MOV   REG[0x5],0x7F      (0091) 	mov	reg[05h], 7fh		; Port_1_DriveMode_1 register (PRT1DM1)
02C3: 70 EF    AND   F,0xEF             
                                        (0092) 	M8C_SetBank0
02C5: 62 07 7F MOV   REG[0x7],0x7F      (0093) 	mov	reg[07h], 7fh		; Port_1_DriveMode_2 register (PRT1DM2)
02C8: 62 06 00 MOV   REG[0x6],0x0       (0094) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
02CB: 71 10    OR    F,0x10             
                                        (0095) 	M8C_SetBank1
02CD: 62 06 00 MOV   REG[0x6],0x0       (0096) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
02D0: 62 07 00 MOV   REG[0x7],0x0       (0097) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
02D3: 70 EF    AND   F,0xEF             
                                        (0098) 	M8C_SetBank0
02D5: 62 05 00 MOV   REG[0x5],0x0       (0099) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
02D8: 62 08 00 MOV   REG[0x8],0x0       (0100) 	mov	reg[08h], 00h		; Port_2_Data register (PRT2DR)
02DB: 71 10    OR    F,0x10             
                                        (0101) 	M8C_SetBank1
02DD: 62 08 00 MOV   REG[0x8],0x0       (0102) 	mov	reg[08h], 00h		; Port_2_DriveMode_0 register (PRT2DM0)
02E0: 62 09 FF MOV   REG[0x9],0xFF      (0103) 	mov	reg[09h], ffh		; Port_2_DriveMode_1 register (PRT2DM1)
02E3: 70 EF    AND   F,0xEF             
                                        (0104) 	M8C_SetBank0
02E5: 62 0B FF MOV   REG[0xB],0xFF      (0105) 	mov	reg[0bh], ffh		; Port_2_DriveMode_2 register (PRT2DM2)
02E8: 62 0A 00 MOV   REG[0xA],0x0       (0106) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
02EB: 71 10    OR    F,0x10             
                                        (0107) 	M8C_SetBank1
02ED: 62 0A 00 MOV   REG[0xA],0x0       (0108) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
02F0: 62 0B 00 MOV   REG[0xB],0x0       (0109) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
02F3: 70 EF    AND   F,0xEF             
                                        (0110) 	M8C_SetBank0
02F5: 62 09 00 MOV   REG[0x9],0x0       (0111) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
02F8: 62 0C 00 MOV   REG[0xC],0x0       (0112) 	mov	reg[0ch], 00h		; Port_3_Data register (PRT3DR)
02FB: 71 10    OR    F,0x10             
                                        (0113) 	M8C_SetBank1
02FD: 62 0C 00 MOV   REG[0xC],0x0       (0114) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
0300: 62 0D 00 MOV   REG[0xD],0x0       (0115) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
0303: 70 EF    AND   F,0xEF             
                                        (0116) 	M8C_SetBank0
0305: 62 0F 00 MOV   REG[0xF],0x0       (0117) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
0308: 62 0E 00 MOV   REG[0xE],0x0       (0118) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
030B: 71 10    OR    F,0x10             
                                        (0119) 	M8C_SetBank1
030D: 62 0E 00 MOV   REG[0xE],0x0       (0120) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
0310: 62 0F 00 MOV   REG[0xF],0x0       (0121) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
0313: 70 EF    AND   F,0xEF             
                                        (0122) 	M8C_SetBank0
0315: 62 0D 00 MOV   REG[0xD],0x0       (0123) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0318: 62 10 00 MOV   REG[0x10],0x0      (0124) 	mov	reg[10h], 00h		; Port_4_Data register (PRT4DR)
031B: 71 10    OR    F,0x10             
                                        (0125) 	M8C_SetBank1
031D: 62 10 00 MOV   REG[0x10],0x0      (0126) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
0320: 62 11 00 MOV   REG[0x11],0x0      (0127) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
0323: 70 EF    AND   F,0xEF             
                                        (0128) 	M8C_SetBank0
0325: 62 13 00 MOV   REG[0x13],0x0      (0129) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
0328: 62 12 00 MOV   REG[0x12],0x0      (0130) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
032B: 71 10    OR    F,0x10             
                                        (0131) 	M8C_SetBank1
032D: 62 12 00 MOV   REG[0x12],0x0      (0132) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0330: 62 13 00 MOV   REG[0x13],0x0      (0133) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
0333: 70 EF    AND   F,0xEF             
                                        (0134) 	M8C_SetBank0
0335: 62 11 00 MOV   REG[0x11],0x0      (0135) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
0338: 62 14 00 MOV   REG[0x14],0x0      (0136) 	mov	reg[14h], 00h		; Port_5_Data register (PRT5DR)
033B: 71 10    OR    F,0x10             
                                        (0137) 	M8C_SetBank1
033D: 62 14 00 MOV   REG[0x14],0x0      (0138) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
0340: 62 15 00 MOV   REG[0x15],0x0      (0139) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
0343: 70 EF    AND   F,0xEF             
                                        (0140) 	M8C_SetBank0
0345: 62 17 00 MOV   REG[0x17],0x0      (0141) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
0348: 62 16 00 MOV   REG[0x16],0x0      (0142) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
034B: 71 10    OR    F,0x10             
                                        (0143) 	M8C_SetBank1
034D: 62 16 00 MOV   REG[0x16],0x0      (0144) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0350: 62 17 00 MOV   REG[0x17],0x0      (0145) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0353: 70 EF    AND   F,0xEF             
                                        (0146) 	M8C_SetBank0
0355: 62 15 00 MOV   REG[0x15],0x0      (0147) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
0358: 62 18 00 MOV   REG[0x18],0x0      (0148) 	mov	reg[18h], 00h		; Port_6_Data register (PRT6DR)
035B: 71 10    OR    F,0x10             
                                        (0149) 	M8C_SetBank1
035D: 62 18 00 MOV   REG[0x18],0x0      (0150) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
0360: 62 19 00 MOV   REG[0x19],0x0      (0151) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
0363: 70 EF    AND   F,0xEF             
                                        (0152) 	M8C_SetBank0
0365: 62 1B 00 MOV   REG[0x1B],0x0      (0153) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
0368: 62 1A 00 MOV   REG[0x1A],0x0      (0154) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
036B: 71 10    OR    F,0x10             
                                        (0155) 	M8C_SetBank1
036D: 62 1A 00 MOV   REG[0x1A],0x0      (0156) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
0370: 62 1B 00 MOV   REG[0x1B],0x0      (0157) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
0373: 70 EF    AND   F,0xEF             
                                        (0158) 	M8C_SetBank0
0375: 62 19 00 MOV   REG[0x19],0x0      (0159) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
0378: 62 1C 00 MOV   REG[0x1C],0x0      (0160) 	mov	reg[1ch], 00h		; Port_7_Data register (PRT7DR)
037B: 71 10    OR    F,0x10             
                                        (0161) 	M8C_SetBank1
037D: 62 1C 00 MOV   REG[0x1C],0x0      (0162) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
0380: 62 1D 00 MOV   REG[0x1D],0x0      (0163) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
0383: 70 EF    AND   F,0xEF             
                                        (0164) 	M8C_SetBank0
0385: 62 1F 00 MOV   REG[0x1F],0x0      (0165) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
0388: 62 1E 00 MOV   REG[0x1E],0x0      (0166) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
038B: 71 10    OR    F,0x10             
                                        (0167) 	M8C_SetBank1
038D: 62 1E 00 MOV   REG[0x1E],0x0      (0168) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
0390: 62 1F 00 MOV   REG[0x1F],0x0      (0169) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
0393: 70 EF    AND   F,0xEF             
                                        (0170) 	M8C_SetBank0
0395: 62 1D 00 MOV   REG[0x1D],0x0      (0171) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
0398: 70 EF    AND   F,0xEF             
                                        (0172) 	M8C_SetBank0
039A: 7F       RET                      (0173) 	ret
                                        (0174) 
                                        (0175) 
                                        (0176) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.3.2710
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_AN2100_29_Loader
                                        (0026) export _LoadConfig_AN2100_29_Loader
                                        (0027) 
                                        (0028) export NO_SHADOW
                                        (0029) export _NO_SHADOW
                                        (0030) 
                                        (0031) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0032) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0033) 
                                        (0034) AREA psoc_config(rom, rel)
                                        (0035) 
                                        (0036) ;---------------------------------------------------------------------------
                                        (0037) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0038) ;                  parameters handled by boot code, like CPU speed). This
                                        (0039) ;                  function can be called from user code, but typically it
                                        (0040) ;                  is only called from boot.
                                        (0041) ;
                                        (0042) ;       INPUTS: None.
                                        (0043) ;      RETURNS: Nothing.
                                        (0044) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0045) ;               In the large memory model currently only the page
                                        (0046) ;               pointer registers listed below are modified.  This does
                                        (0047) ;               not guarantee that in future implementations of this
                                        (0048) ;               function other page pointer registers will not be
                                        (0049) ;               modified.
                                        (0050) ;          
                                        (0051) ;               Page Pointer Registers Modified: 
                                        (0052) ;               CUR_PP
                                        (0053) ;
                                        (0054) _LoadConfigInit:
                                        (0055)  LoadConfigInit:
                                        (0056)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0057)     
039B: 7C 03 A2 LCALL 0x03A2             (0058) 	lcall	LoadConfig_AN2100_29_Loader
039E: 7C 02 96 LCALL 0x0296             (0059) 	lcall	LoadConfigTBL_AN2100_29_Loader_Ordered
                                        (0060) 
                                        (0061) 
                                        (0062)     RAM_EPILOGUE RAM_USE_CLASS_4
03A1: 7F       RET                      (0063)     ret
                                        (0064) 
                                        (0065) ;---------------------------------------------------------------------------
                                        (0066) ; Load Configuration AN2100_29_Loader
                                        (0067) ;
                                        (0068) ;    Load configuration registers for AN2100_29_Loader.
                                        (0069) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0070) ;
                                        (0071) ;       INPUTS: None.
                                        (0072) ;      RETURNS: Nothing.
                                        (0073) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0074) ;               modified as may the Page Pointer registers!
                                        (0075) ;               In the large memory model currently only the page
                                        (0076) ;               pointer registers listed below are modified.  This does
                                        (0077) ;               not guarantee that in future implementations of this
                                        (0078) ;               function other page pointer registers will not be
                                        (0079) ;               modified.
                                        (0080) ;          
                                        (0081) ;               Page Pointer Registers Modified: 
                                        (0082) ;               CUR_PP
                                        (0083) ;
                                        (0084) _LoadConfig_AN2100_29_Loader:
                                        (0085)  LoadConfig_AN2100_29_Loader:
                                        (0086)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0087) 
03A2: 10       PUSH  X                  (0088) 	push	x
03A3: 70 EF    AND   F,0xEF             
                                        (0089)     M8C_SetBank0                    ; Force bank 0
03A5: 50 00    MOV   A,0x0              (0090)     mov     a, 0                    ; Specify bank 0
03A7: 67       ASR   A                  (0091)     asr     a                       ; Store in carry flag
                                        (0092)                                     ; Load bank 0 table:
03A8: 50 02    MOV   A,0x2              (0093)     mov     A, >LoadConfigTBL_AN2100_29_Loader_Bank0
03AA: 57 20    MOV   X,0x20             (0094)     mov     X, <LoadConfigTBL_AN2100_29_Loader_Bank0
03AC: 7C 03 BD LCALL 0x03BD             (0095)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0096) 
03AF: 50 01    MOV   A,0x1              (0097)     mov     a, 1                    ; Specify bank 1
03B1: 67       ASR   A                  (0098)     asr     a                       ; Store in carry flag
                                        (0099)                                     ; Load bank 1 table:
03B2: 50 02    MOV   A,0x2              (0100)     mov     A, >LoadConfigTBL_AN2100_29_Loader_Bank1
03B4: 57 6F    MOV   X,0x6F             (0101)     mov     X, <LoadConfigTBL_AN2100_29_Loader_Bank1
03B6: 7C 03 BD LCALL 0x03BD             (0102)     lcall   LoadConfig              ; Load the bank 1 values
03B9: 70 EF    AND   F,0xEF             
                                        (0103) 
                                        (0104)     M8C_SetBank0                    ; Force return to bank 0
03BB: 20       POP   X                  (0105) 	pop		x
                                        (0106) 
                                        (0107)     RAM_EPILOGUE RAM_USE_CLASS_4
03BC: 7F       RET                      (0108)     ret
                                        (0109) 
                                        (0110) 
                                        (0111) 
                                        (0112) 
                                        (0113) ;---------------------------------------------------------------------------
                                        (0114) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0115) ;              pairs. Terminate on address=0xFF.
                                        (0116) ;
                                        (0117) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0118) ;           Flag Register Carry bit encodes the Register Bank
                                        (0119) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0120) ;
                                        (0121) ;  RETURNS: nothing.
                                        (0122) ;
                                        (0123) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0124) ;                X-3 Temporary store for register address
                                        (0125) ;                X-2 LSB of config table address
                                        (0126) ;                X-1 MSB of config table address
                                        (0127) ;
                                        (0128) LoadConfig:
                                        (0129)     RAM_PROLOGUE RAM_USE_CLASS_2
03BD: 38 02    ADD   SP,0x2             (0130)     add     SP, 2                   ; Set up local vars
03BF: 10       PUSH  X                  (0131)     push    X                       ; Save config table address on stack
03C0: 08       PUSH  A                  (0132)     push    A
03C1: 4F       MOV   X,SP               (0133)     mov     X, SP
03C2: 56 FC 00 MOV   [X-4],0x0          (0134)     mov     [X-4], 0                ; Set default Destination to Bank 0
03C5: D0 04    JNC   0x03CA             (0135)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
03C7: 56 FC 01 MOV   [X-4],0x1          (0136)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0137) .BankSelectSaved:
03CA: 18       POP   A                  (0138)     pop     A
03CB: 20       POP   X                  (0139)     pop     X
03CC: 70 EF    AND   F,0xEF             
03CE: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0140) 
                                        (0141) LoadConfigLp:
                                        (0142)     M8C_SetBank0                    ; Switch to bank 0
                                        (0143)     M8C_ClearWDT                    ; Clear the watchdog for long inits
03D1: 10       PUSH  X                  (0144)     push    X                       ; Preserve the config table address
03D2: 08       PUSH  A                  (0145)     push    A
03D3: 28       ROMX                     (0146)     romx                            ; Load register address from table
03D4: 39 FF    CMP   A,0xFF             (0147)     cmp     A, END_CONFIG_TABLE     ; End of table?
03D6: A0 1F    JZ    0x03F6             (0148)     jz      EndLoadConfig           ;   Yes, go wrap it up
03D8: 4F       MOV   X,SP               (0149)     mov     X, SP                   ;
03D9: 48 FC 01 TST   [X-4],0x1          (0150)     tst     [X-4], 1                ; Loading IO Bank 1?
03DC: A0 03    JZ    0x03E0             (0151)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
03DE: 71 10    OR    F,0x10             
                                        (0152)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0153) .IOBankNowSet:
03E0: 54 FD    MOV   [X-3],A            (0154)     mov     [X-3], A                ; Stash the register address
03E2: 18       POP   A                  (0155)     pop     A                       ; Retrieve the table address
03E3: 20       POP   X                  (0156)     pop     X
03E4: 75       INC   X                  (0157)     inc     X                       ; Advance to the data byte
03E5: 09 00    ADC   A,0x0              (0158)     adc     A, 0
03E7: 10       PUSH  X                  (0159)     push    X                       ; Save the config table address again
03E8: 08       PUSH  A                  (0160)     push    A
03E9: 28       ROMX                     (0161)     romx                            ; load config data from the table
03EA: 4F       MOV   X,SP               (0162)     mov     X, SP                   ; retrieve the register address
03EB: 59 FD    MOV   X,[X-3]            (0163)     mov     X, [X-3]
03ED: 61 00    MOV   REG[X+0x0],A       (0164)     mov     reg[X], A               ; Configure the register
03EF: 18       POP   A                  (0165)     pop     A                       ; retrieve the table address
03F0: 20       POP   X                  (0166)     pop     X
03F1: 75       INC   X                  (0167)     inc     X                       ; advance to next table entry
03F2: 09 00    ADC   A,0x0              (0168)     adc     A, 0
03F4: 8F D7    JMP   0x03CC             (0169)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0170) EndLoadConfig:
03F6: 38 FC    ADD   SP,0xFC            (0171)     add     SP, -4
03F8: 70 3F    AND   F,0x3F             
03FA: 71 C0    OR    F,0xC0             
                                        (0172)     RAM_EPILOGUE RAM_USE_CLASS_2
03FC: 7F       RET                      (0173)     ret
                                        (0174) 
                                        (0175) AREA InterruptRAM(ram, rel)
                                        (0176) 
                                        (0177) NO_SHADOW:
                                        (0178) _NO_SHADOW:
FILE: C:\Users\IBM\Desktop\CYPRES~1\SERIAL~1\PSOC1_~1\PSOC1_~1\AN2100\AN2100\AN2100~1\AN2100~1\main.c
(0001) /////////////////////////////////////////////////////////////////////////////////
(0002) // Cypress Semiconductor Corporation
(0003) // Cypress’ Source Code: Copyright 2010, Cypress Semiconductor Corporation.
(0004) // This Source Code (software and/or firmware) is owned by Cypress Semiconductor
(0005) // Corporation (Cypress) and is protected by and subject to worldwide patent 
(0006) // protection (United States and foreign), United States copyright laws and 
(0007) // international treaty provisions. Cypress hereby grants to licensee a personal,
(0008) // non-exclusive, non-transferable license to copy, use, modify, create 
(0009) // derivative works of, and compile the Cypress Source Code and derivative works
(0010) // for the sole purpose of creating custom software and or firmware in support
(0011) // of licensee product to be used only in conjunction with a Cypress integrated
(0012) // circuit as specified in the applicable agreement. Any reproduction,
(0013) // modification, translation, compilation, or representation of this Source Code
(0014) // except as specified above is prohibited without the express written
(0015) // permission of Cypress. 
(0016) // Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
(0017) // REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
(0018) // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
(0019) // Cypress reserves the right to make changes without further notice to the
(0020) // materials described herein. Cypress does not assume any liability arising
(0021) // out of the application or use of any product or circuit described herein.
(0022) // Cypress does not authorize its products for use as critical components in
(0023) // life-support systems where a malfunction or failure may reasonably be expected
(0024) // to result in significant injury to the user. The inclusion of Cypress’ product
(0025) // in a life-support systems application implies that the manufacturer assumes
(0026) // all risk of such use and in doing so indemnifies Cypress against all charges.
(0027) //
(0028) // Use may be limited by and subject to the applicable Cypress software license
(0029) // agreement.
(0030) //
(0031) /////////////////////////////////////////////////////////////////////////////////
(0032) 
(0033) //----------------------------------------------------------------------------
(0034) // C main line
(0035) //----------------------------------------------------------------------------
(0036) 
(0037) 
(0038) #include <m8c.h>        // part specific constants and macros
(0039) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0040) #include "BLconf.h"
(0041) 
(0042) void main(void)
(0043) {
__text_start|_main|_main:
  i                    --> X+4
  x                    --> X+0
    03FD: 10       PUSH  X
    03FE: 4F       MOV   X,SP
    03FF: 38 05    ADD   SP,0x5
(0044)     long int x;
(0045) 	char i=0;
    0401: 56 04 00 MOV   [X+4],0x0
    0404: 80 40    JMP   0x0445
(0046)      	
(0047)  	while(1){
(0048)  	    if(i)
    0406: 3D 04 00 CMP   [X+4],0x0
    0409: A0 09    JZ    0x0413
(0049) 		{
(0050) 			i=0;
    040B: 56 04 00 MOV   [X+4],0x0
(0051) 			BOOTLOADER_MODE_LED_OFF();
    040E: 41 04 7F AND   REG[0x4],0x7F
(0052) 		}else{
    0411: 80 07    JMP   0x0419
(0053) 			i=1;
    0413: 56 04 01 MOV   [X+4],0x1
(0054) 			BOOTLOADER_MODE_LED_ON();
    0416: 43 04 80 OR    REG[0x4],0x80
(0055) 		}
(0056) 		for (x=0; x<20000; x++);	//delay
    0419: 56 00 00 MOV   [X+0],0x0
    041C: 56 01 00 MOV   [X+1],0x0
    041F: 56 02 00 MOV   [X+2],0x0
    0422: 56 03 00 MOV   [X+3],0x0
    0425: 07 03 01 ADD   [X+3],0x1
    0428: 0F 02 00 ADC   [X+2],0x0
    042B: 0F 01 00 ADC   [X+1],0x0
    042E: 0F 00 00 ADC   [X+0],0x0
    0431: 52 03    MOV   A,[X+3]
    0433: 11 20    SUB   A,0x20
    0435: 52 02    MOV   A,[X+2]
    0437: 19 4E    SBB   A,0x4E
    0439: 52 01    MOV   A,[X+1]
    043B: 19 00    SBB   A,0x0
    043D: 52 00    MOV   A,[X+0]
    043F: 31 80    XOR   A,0x80
    0441: 19 80    SBB   A,0x80
    0443: CF E1    JC    0x0425
(0057)   	}
    0445: 8F C0    JMP   0x0406
(0058)   	
(0059) }
    0447: 38 FB    ADD   SP,0xFB
    0449: 20       POP   X
    044A: 8F FF    JMP   0x044A
FILE: .\boot.asm
7400: 71 10    OR    F,0x10             
                                        (0729) 
                                        (0730) IF	(TOOLCHAIN & HITECH)
                                        (0731) ELSE
                                        (0732)     ;---------------------------------
                                        (0733)     ; Order Critical RAM & ROM AREAs
                                        (0734)     ;---------------------------------
                                        (0735)     ;  'TOP' is all that has been defined so far...
                                        (0736) 
                                        (0737)     ;  ROM AREAs for C CONST, static & global items
                                        (0738)     ;
                                        (0739)     AREA lit               (ROM, REL, CON)   ; 'const' definitions
                                        (0740)     AREA idata             (ROM, REL, CON)   ; Constants for initializing RAM
                                        (0741) __idata_start:
                                        (0742) 
                                        (0743)     AREA func_lit          (ROM, REL, CON)   ; Function Pointers
                                        (0744) __func_lit_start:
                                        (0745) 
                                        (0746) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0747)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0748)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0749)     ; relocated by the code compressor, but the text area may shrink and
                                        (0750)     ; that moves xidata around.
                                        (0751)     ;
                                        (0752) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0753) ENDIF
                                        (0754) 
                                        (0755)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0756)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0757) 
                                        (0758)     ; CODE segment for general use
                                        (0759)     ;
                                        (0760)     AREA text (ROM, REL, CON)
                                        (0761) __text_start:
                                        (0762) 
                                        (0763)     ; RAM area usage
                                        (0764)     ;
                                        (0765)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0766) __data_start:
                                        (0767) 
                                        (0768)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0769)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0770)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0771) __bss_start:
                                        (0772) 
                                        (0773) ENDIF ; TOOLCHAIN
                                        (0774) ;---------------------------------------------
                                        (0775) ;---------------------------------------------
                                        (0776) ;---------------------------------------------
                                        (0777) ; BootLoader Start procedure
                                        (0778) ;---------------------------------------------
                                        (0779) ;---------------------------------------------
                                        (0780) ;---------------------------------------------
                                        (0781) IF	(TOOLCHAIN & HITECH)
                                        (0782) psect BootLoaderArea global
                                        (0783) ELSE
                                        (0784) Area BootLoaderArea(ROM,REL,CON)
                                        (0785) ENDIF
                                        (0786) __Boot_Start:
                                        (0787)     ; initialize SMP values for voltage stabilization, if required,
                                        (0788)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0789)     ; least for now. 
                                        (0790)     ;
                                        (0791)     M8C_SetBank1
7402: 62 E3 87 MOV   REG[0xE3],0x87     (0792)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
7405: 70 EF    AND   F,0xEF             
                                        (0793)     M8C_SetBank0
                                        (0794) 
7407: 41 FE FB AND   REG[0xFE],0xFB     (0795)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0796) 
                                        (0797) boot_stack_start:          equ 80h
740A: 50 80    MOV   A,0x80             (0798)     mov   A, boot_stack_start          ; Set top of stack to end of used RAM
740C: 4E       SWAP  SP,A               (0799)     swap  SP, A                        ; This is only temporary if going to LMM
                                        (0800) 
                                        (0801)     ;-----------------------------------------------
                                        (0802)     ; Set Power-related Trim & the AGND Bypass bit.
                                        (0803)     ;-----------------------------------------------
                                        (0804) 
                                        (0805) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0806)                                           ; *** 12MHZ Main Oscillator ***
                                        (0807)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0808) 
                                        (0809) ENDIF ; 3.3 Volt Operation
                                        (0810) 
740D: 55 F8 00 MOV   [0xF8],0x0         (0811)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
7410: 55 F9 00 MOV   [0xF9],0x0         (0812)     mov  [bSSC_KEYSP], 0
7413: 71 10    OR    F,0x10             
                                        (0813) 
                                        (0814)     ; Either no ECO, or waiting for stable clock is to be done in main
                                        (0815)     M8C_SetBank1
7415: 62 E0 02 MOV   REG[0xE0],0x2      (0816)     mov   reg[OSC_CR0], OSC_CR0_CPU_12MHz
7418: 70 EF    AND   F,0xEF             
741A: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0817)     M8C_SetBank0
                                        (0818)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0819) 
                                        (0820)     ;------------------------
                                        (0821)     ; Close CT leakage path.
                                        (0822)     ;------------------------
741D: 62 71 05 MOV   REG[0x71],0x5      (0823)     mov   reg[ACB00CR0], 05h
7420: 62 75 05 MOV   REG[0x75],0x5      (0824)     mov   reg[ACB01CR0], 05h
7423: 62 79 05 MOV   REG[0x79],0x5      (0825)     mov   reg[ACB02CR0], 05h
7426: 62 7D 05 MOV   REG[0x7D],0x5      (0826)     mov   reg[ACB03CR0], 05h
7429: 62 D1 07 MOV   REG[0xD1],0x7      
                                        (0827) IF	(TOOLCHAIN & HITECH)
                                        (0828)     ;---------------------------------------------
                                        (0829)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0830)     ;---------------------------------------------
                                        (0831) 	global		__Lstackps
                                        (0832) 	mov     a,low __Lstackps
                                        (0833) 	swap    a,sp
                                        (0834) 
                                        (0835) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0836)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0837)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0838)     RAM_SETPAGE_CUR 0
                                        (0839)     RAM_SETPAGE_MVW 0
                                        (0840)     RAM_SETPAGE_MVR 0
                                        (0841)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0842)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0843)     ELSE
                                        (0844)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0845)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0846) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0847) ELSE
                                        (0848)     ;---------------------------------------------
                                        (0849)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0850)     ;---------------------------------------------
                                        (0851) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0852)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
742C: 50 00    MOV   A,0x0              (0853)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
742E: 4E       SWAP  SP,A               (0854)     swap  A, SP
742F: 62 D3 07 MOV   REG[0xD3],0x7      
7432: 62 D0 00 MOV   REG[0xD0],0x0      
7435: 62 D5 00 MOV   REG[0xD5],0x0      
7438: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0855)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0856)     RAM_SETPAGE_CUR 0
                                        (0857)     RAM_SETPAGE_MVW 0
                                        (0858)     RAM_SETPAGE_MVR 0
                                        (0859) 
                                        (0860)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
743B: 71 C0    OR    F,0xC0             (0861)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0862)   ELSE
                                        (0863)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0864)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0865) ELSE
                                        (0866)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0867)     swap  SP, A
                                        (0868) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0869) ENDIF ;	TOOLCHAIN
                                        (0870) 
                                        (0871)     ;-------------------------
                                        (0872)     ; Load Base Configuration
                                        (0873)     ;-------------------------
                                        (0874)     ; Load global parameter settings and load the user modules in the
                                        (0875)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0876)     ; to minimize start up time; (2) We may still need to play with the
                                        (0877)     ; Sleep Timer.
                                        (0878)     ;
743D: 7C 7A A3 LCALL 0x7AA3             (0879)     lcall Boot_LoadConfigInit
7440: 71 10    OR    F,0x10             
                                        (0880) 
                                        (0881)     ;-------------------------------
                                        (0882)     ; Voltage Stabilization for SMP
                                        (0883)     ;-------------------------------
                                        (0884) 
                                        (0885) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0886) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0887)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0888)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0889)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0890)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0891)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0892)     M8C_SetBank1
                                        (0893)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0894)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0895)     M8C_SetBank0
                                        (0896)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0897)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0898) Boot_WaitFor2ms:
                                        (0899)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0900)     jz   Boot_WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0901) ENDIF ; SMP is operational
                                        (0902) ENDIF ; 5.0V Operation
                                        (0903) 
                                        (0904)     ;-------------------------------
                                        (0905)     ; Set Power-On Reset (POR) Level
                                        (0906)     ;-------------------------------
                                        (0907)     M8C_SetBank1
                                        (0908) 
                                        (0909) IF (POWER_SETTING & POWER_SET_5V0)          ; 5.0V Operation?
7442: 43 E3 20 OR    REG[0xE3],0x20     (0910)      or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
7445: 70 EF    AND   F,0xEF             
                                        (0911) ENDIF ; 5.0V Operation
                                        (0912) 
                                        (0913) 
                                        (0914)     M8C_SetBank0
                                        (0915) 
                                        (0916)     ;----------------------------
                                        (0917)     ; Wrap up and invoke "main"
                                        (0918)     ;----------------------------
                                        (0919) 
                                        (0920)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0921)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0922)     ;
7447: 62 E0 00 MOV   REG[0xE0],0x0      (0923)     mov  reg[INT_MSK0],0
744A: 71 10    OR    F,0x10             
                                        (0924) 
                                        (0925)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0926)     ;
                                        (0927)     M8C_SetBank1
                                        (0928) //    mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
744C: 62 E0 02 MOV   REG[0xE0],0x2      (0929)     mov  reg[OSC_CR0],2	// set 12MHz CPU Speed
744F: 70 EF    AND   F,0xEF             
                                        (0930)     M8C_SetBank0
                                        (0931) 
                                        (0932)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0933)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0934)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0935)     ;
7451: 62 E2 00 MOV   REG[0xE2],0x0      (0936)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0937)                                    ; have been set during the boot process.
7454: 7C 78 13 LCALL _BootLoader        (0938)     lcall _BootLoader                    ; call main
                                        (0939) Boot_Exit:
7457: 8F FF    JMP   0x7457             (0940)     jmp  Boot_Exit                     ; Wait here after return till power-off or reset
                                        (0941) 
                                        (0942) ; end of file boot.asm
FILE: C:\Users\IBM\Desktop\CYPRES~1\SERIAL~1\PSOC1_~1\PSOC1_~1\AN2100\AN2100\AN2100~1\AN2100~1\bootloader.c
(0001) /////////////////////////////////////////////////////////////////////////////////
(0002) // Cypress Semiconductor Corporation
(0003) // Cypress’ Source Code: Copyright 2010, Cypress Semiconductor Corporation.
(0004) // This Source Code (software and/or firmware) is owned by Cypress Semiconductor
(0005) // Corporation (Cypress) and is protected by and subject to worldwide patent 
(0006) // protection (United States and foreign), United States copyright laws and 
(0007) // international treaty provisions. Cypress hereby grants to licensee a personal,
(0008) // non-exclusive, non-transferable license to copy, use, modify, create 
(0009) // derivative works of, and compile the Cypress Source Code and derivative works
(0010) // for the sole purpose of creating custom software and or firmware in support
(0011) // of licensee product to be used only in conjunction with a Cypress integrated
(0012) // circuit as specified in the applicable agreement. Any reproduction,
(0013) // modification, translation, compilation, or representation of this Source Code
(0014) // except as specified above is prohibited without the express written
(0015) // permission of Cypress. 
(0016) // Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
(0017) // REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
(0018) // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
(0019) // Cypress reserves the right to make changes without further notice to the
(0020) // materials described herein. Cypress does not assume any liability arising
(0021) // out of the application or use of any product or circuit described herein.
(0022) // Cypress does not authorize its products for use as critical components in
(0023) // life-support systems where a malfunction or failure may reasonably be expected
(0024) // to result in significant injury to the user. The inclusion of Cypress’ product
(0025) // in a life-support systems application implies that the manufacturer assumes
(0026) // all risk of such use and in doing so indemnifies Cypress against all charges.
(0027) //
(0028) // Use may be limited by and subject to the applicable Cypress software license
(0029) // agreement.
(0030) //
(0031) /////////////////////////////////////////////////////////////////////////////////
(0032) 
(0033) #include <m8c.h>        // part specific constants and macros
(0034) #include "bootloader.h"    // API definitions for all BootLoader Modules
(0035) #include <FlashBlock.h>
(0036) #include "BLconf.h"
(0037) 
(0038) #ifdef HI_TECH_C
(0039) asm("global __Start");
(0040) #endif
(0041) 
(0042) #define LAST_BLOCK_TO_CHECK	0		// Minimum = 1; Maximum = 455; if 0 then don't calculate CS
(0043) #define ENABLE_CONNECT_BY_PSOC	1	// 0-disable 	1-enable
(0044) 
(0045) 
(0046) #ifdef HI_TECH_C
(0047) #pragma psect text=BootCheckSum
(0048) #else
(0049) #pragma text:BootCheckSum
(0050) #endif
(0051) #pragma abs_address:0x7200
(0052) const char BootCheckSumBlock[];
(0053) #pragma abs_address:0x73FE
(0054) const int LastBlock_To_Check = LAST_BLOCK_TO_CHECK;
(0055) #pragma end_abs_address
(0056) 
(0057) 
(0058) #ifdef HI_TECH_C
(0059) #pragma psect text=BootLoaderArea
(0060) #else
(0061) #pragma text:BootLoaderArea
(0062) #endif
(0063) 
(0064) //extern void Boot_LoadConfigInit(void);
(0065) extern char FlashCheckSum(int);
(0066) extern char Boot_Is_Program_Good(void);
(0067) 
(0068) char Boot_ASCIItoBYTE(char Low,char High){
_Boot_ASCIItoBYTE:
  byte                 --> X+0
  High                 --> X-5
  Low                  --> X-4
    7459: 10       PUSH  X
    745A: 4F       MOV   X,SP
    745B: 38 01    ADD   SP,0x1
(0069)     char byte; 
(0070) 	if (High>='a') byte=(High-'a'+10)<<4; else byte=(High-'0')<<4;
    745D: 3D FB 61 CMP   [X-5],0x61
    7460: C0 17    JC    0x7478
    7462: 62 D0 00 MOV   REG[0xD0],0x0
    7465: 52 FB    MOV   A,[X-5]
    7467: 11 61    SUB   A,0x61
    7469: 53 06    MOV   [__r0],A
    746B: 06 06 0A ADD   [__r0],0xA
    746E: 51 06    MOV   A,[__r0]
    7470: 64       ASL   A
    7471: 64       ASL   A
    7472: 64       ASL   A
    7473: 64       ASL   A
    7474: 54 00    MOV   [X+0],A
    7476: 80 0E    JMP   0x7485
    7478: 62 D0 00 MOV   REG[0xD0],0x0
    747B: 52 FB    MOV   A,[X-5]
    747D: 11 30    SUB   A,0x30
    747F: 64       ASL   A
    7480: 64       ASL   A
    7481: 64       ASL   A
    7482: 64       ASL   A
    7483: 54 00    MOV   [X+0],A
(0071) 	if (Low>='a') byte|=(Low-'a'+10); else byte|=(Low-'0');
    7485: 3D FC 61 CMP   [X-4],0x61
    7488: C0 13    JC    0x749C
    748A: 62 D0 00 MOV   REG[0xD0],0x0
    748D: 52 FC    MOV   A,[X-4]
    748F: 11 61    SUB   A,0x61
    7491: 53 06    MOV   [__r0],A
    7493: 06 06 0A ADD   [__r0],0xA
    7496: 51 06    MOV   A,[__r0]
    7498: 2D 00    OR    [X+0],A
    749A: 80 0A    JMP   0x74A5
    749C: 62 D0 00 MOV   REG[0xD0],0x0
    749F: 52 FC    MOV   A,[X-4]
    74A1: 11 30    SUB   A,0x30
    74A3: 2D 00    OR    [X+0],A
(0072) 	return byte;
    74A5: 52 00    MOV   A,[X+0]
    74A7: 62 D0 00 MOV   REG[0xD0],0x0
    74AA: 38 FF    ADD   SP,0xFF
    74AC: 20       POP   X
    74AD: 7F       RET   
(0073) }
(0074) 
(0075) BYTE Boot_UART_cGetChar(void){
_Boot_UART_cGetChar:
  bRxStatus            --> X+0
    74AE: 10       PUSH  X
    74AF: 4F       MOV   X,SP
    74B0: 38 01    ADD   SP,0x1
(0076) 	BYTE bRxStatus;
(0077) 	while (!(bRxStatus=Boot_RxD_bReadRxStatus() & RX8_RX_COMPLETE));
    74B2: 10       PUSH  X
    74B3: 7C 7C 9C LCALL 0x7C9C
    74B6: 20       POP   X
    74B7: 62 D0 00 MOV   REG[0xD0],0x0
    74BA: 53 06    MOV   [__r0],A
    74BC: 26 06 08 AND   [__r0],0x8
    74BF: 51 06    MOV   A,[__r0]
    74C1: 54 00    MOV   [X+0],A
    74C3: 3C 06 00 CMP   [__r0],0x0
    74C6: AF EB    JZ    0x74B2
(0078)     return Boot_RxD_bReadRxData();
    74C8: 10       PUSH  X
    74C9: 7C 7C 99 LCALL 0x7C99
    74CC: 20       POP   X
    74CD: 62 D0 00 MOV   REG[0xD0],0x0
    74D0: 38 FF    ADD   SP,0xFF
    74D2: 20       POP   X
    74D3: 7F       RET   
(0079) }
(0080) 
(0081) void Boot_UART_PutChar(char TxData){
_Boot_UART_PutChar:
  TxData               --> X-4
    74D4: 10       PUSH  X
    74D5: 4F       MOV   X,SP
(0082) 	while (!(Boot_TxD_bReadTxStatus() & TX8_TX_BUFFER_EMPTY));
    74D6: 10       PUSH  X
    74D7: 7C 7C A7 LCALL 0x7CA7
    74DA: 20       POP   X
    74DB: 62 D0 00 MOV   REG[0xD0],0x0
    74DE: 53 06    MOV   [__r0],A
    74E0: 47 06 10 TST   [__r0],0x10
    74E3: AF F2    JZ    0x74D6
(0083) 	Boot_TxD_SendData(TxData);     
    74E5: 10       PUSH  X
    74E6: 52 FC    MOV   A,[X-4]
    74E8: 7C 7C A4 LCALL 0x7CA4
    74EB: 20       POP   X
    74EC: 20       POP   X
    74ED: 7F       RET   
(0084) }
(0085) 
(0086) void Boot_UART_CPutString(char* pstr){
_Boot_UART_CPutString:
  pstr                 --> X-5
    74EE: 10       PUSH  X
    74EF: 4F       MOV   X,SP
    74F0: 80 18    JMP   0x7509
(0087) 	while (*pstr != 0){
(0088) 	   Boot_UART_PutChar(*pstr);
    74F2: 62 D0 00 MOV   REG[0xD0],0x0
    74F5: 52 FC    MOV   A,[X-4]
    74F7: 53 05    MOV   [__r1],A
    74F9: 52 FB    MOV   A,[X-5]
    74FB: 60 D4    MOV   REG[0xD4],A
    74FD: 3E 05    MVI   A,[__r1]
    74FF: 08       PUSH  A
    7500: 9F D2    CALL  _Boot_UART_PutChar
    7502: 38 FF    ADD   SP,0xFF
(0089) 	   pstr++;
    7504: 77 FC    INC   [X-4]
    7506: 0F FB 00 ADC   [X-5],0x0
(0090) 	}
    7509: 62 D0 00 MOV   REG[0xD0],0x0
    750C: 52 FC    MOV   A,[X-4]
    750E: 53 05    MOV   [__r1],A
    7510: 52 FB    MOV   A,[X-5]
    7512: 60 D4    MOV   REG[0xD4],A
    7514: 3E 05    MVI   A,[__r1]
    7516: 39 00    CMP   A,0x0
    7518: BF D9    JNZ   0x74F2
    751A: 20       POP   X
    751B: 7F       RET   
(0091) }
(0092) 
(0093) void Boot_PerformWrite(void){
_Boot_PerformWrite:
  BlockID              --> X+82
  led                  --> X+81
  j                    --> X+79
  fwStruct             --> X+71
  data                 --> X+3
  cl                   --> X+2
  i                    --> X+1
  ch                   --> X+0
    751C: 10       PUSH  X
    751D: 4F       MOV   X,SP
    751E: 38 54    ADD   SP,0x54
(0094) 	char data[68];
(0095) 	char i,ch,cl;
(0096) 	int BlockID,j;
(0097) 	FLASH_WRITE_STRUCT fwStruct;
(0098) 	char led=0x00;	//LED off
    7520: 56 51 00 MOV   [X+81],0x0
    7523: 81 75    JMP   0x7699
(0099) 
(0100)     while(1){
(0101)        if (led) BOOTLOADER_MODE_LED_OFF(); else BOOTLOADER_MODE_LED_ON();
    7525: 3D 51 00 CMP   [X+81],0x0
    7528: A0 06    JZ    0x752F
    752A: 41 04 7F AND   REG[0x4],0x7F
    752D: 80 04    JMP   0x7532
    752F: 43 04 80 OR    REG[0x4],0x80
(0102)        led=~led;
    7532: 52 51    MOV   A,[X+81]
    7534: 73       CPL   A
    7535: 54 51    MOV   [X+81],A
(0103)        while ((ch=Boot_UART_cGetChar())!='S'); // waiting for start symbol 'S'
    7537: 9F 75    CALL  _Boot_UART_cGetChar
    7539: 62 D0 00 MOV   REG[0xD0],0x0
    753C: 54 00    MOV   [X+0],A
    753E: 39 53    CMP   A,0x53
    7540: BF F6    JNZ   0x7537
(0104) 	   if ((ch = Boot_UART_cGetChar())=='S') break; // All blocks are sent ?
    7542: 9F 6A    CALL  _Boot_UART_cGetChar
    7544: 62 D0 00 MOV   REG[0xD0],0x0
    7547: 54 00    MOV   [X+0],A
    7549: 39 53    CMP   A,0x53
    754B: B0 03    JNZ   0x754F
    754D: 81 4D    JMP   0x769B
(0105) 	      else {
(0106) 		    cl=Boot_UART_cGetChar();       
    754F: 9F 5D    CALL  _Boot_UART_cGetChar
    7551: 62 D0 00 MOV   REG[0xD0],0x0
    7554: 54 02    MOV   [X+2],A
(0107) 	        data[0]=Boot_ASCIItoBYTE(cl,ch);
    7556: 52 00    MOV   A,[X+0]
    7558: 08       PUSH  A
    7559: 52 02    MOV   A,[X+2]
    755B: 08       PUSH  A
    755C: 9E FB    CALL  _Boot_ASCIItoBYTE
    755E: 38 FE    ADD   SP,0xFE
    7560: 62 D0 00 MOV   REG[0xD0],0x0
    7563: 54 03    MOV   [X+3],A
(0108) 	      } 
(0109) 	   for (i=1; i<68; i++) {
    7565: 56 01 01 MOV   [X+1],0x1
    7568: 80 38    JMP   0x75A1
(0110) 	      ch=Boot_UART_cGetChar();  // Read high nibble
    756A: 9F 42    CALL  _Boot_UART_cGetChar
    756C: 62 D0 00 MOV   REG[0xD0],0x0
    756F: 54 00    MOV   [X+0],A
(0111) 	      cl=Boot_UART_cGetChar();  // Read low nibble 
    7571: 9F 3B    CALL  _Boot_UART_cGetChar
    7573: 62 D0 00 MOV   REG[0xD0],0x0
    7576: 54 02    MOV   [X+2],A
(0112) 	      data[i]=Boot_ASCIItoBYTE(cl,ch);  // Write transformed byte in buffer
    7578: 52 00    MOV   A,[X+0]
    757A: 08       PUSH  A
    757B: 52 02    MOV   A,[X+2]
    757D: 08       PUSH  A
    757E: 9E D9    CALL  _Boot_ASCIItoBYTE
    7580: 38 FE    ADD   SP,0xFE
    7582: 62 D0 00 MOV   REG[0xD0],0x0
    7585: 53 06    MOV   [__r0],A
    7587: 55 04 07 MOV   [__r2],0x7
    758A: 5A 03    MOV   [__r3],X
    758C: 06 03 03 ADD   [__r3],0x3
    758F: 52 01    MOV   A,[X+1]
    7591: 02 03    ADD   A,[__r3]
    7593: 53 03    MOV   [__r3],A
    7595: 50 00    MOV   A,0x0
    7597: 0A 04    ADC   A,[__r2]
    7599: 60 D5    MOV   REG[0xD5],A
    759B: 51 06    MOV   A,[__r0]
    759D: 3F 03    MVI   [__r3],A
(0113) 	   } 
    759F: 77 01    INC   [X+1]
    75A1: 3D 01 44 CMP   [X+1],0x44
    75A4: CF C5    JC    0x756A
(0114) 	   
(0115) 	   // Read Last Block Symbol 'F'
(0116) 	   if ((ch=Boot_UART_cGetChar())!='F') ; // Error Info!
    75A6: 9F 06    CALL  _Boot_UART_cGetChar
    75A8: 62 D0 00 MOV   REG[0xD0],0x0
    75AB: 54 00    MOV   [X+0],A
    75AD: 39 46    CMP   A,0x46
    75AF: A0 01    JZ    0x75B1
(0117) 	   
(0118) 	   // Write Block to Flash
(0119) 	   fwStruct.wARG_BlockId = (((int)data[1])<<2) + (data[2]>>6); // Form Block ID form Block Address
    75B1: 62 D0 00 MOV   REG[0xD0],0x0
    75B4: 52 05    MOV   A,[X+5]
    75B6: 53 05    MOV   [__r1],A
    75B8: 55 06 00 MOV   [__r0],0x0
    75BB: 68 06    ASR   [__r0]
    75BD: 6E 05    RRC   [__r1]
    75BF: 68 06    ASR   [__r0]
    75C1: 6E 05    RRC   [__r1]
    75C3: 68 06    ASR   [__r0]
    75C5: 6E 05    RRC   [__r1]
    75C7: 68 06    ASR   [__r0]
    75C9: 6E 05    RRC   [__r1]
    75CB: 68 06    ASR   [__r0]
    75CD: 6E 05    RRC   [__r1]
    75CF: 68 06    ASR   [__r0]
    75D1: 6E 05    RRC   [__r1]
    75D3: 52 04    MOV   A,[X+4]
    75D5: 53 03    MOV   [__r3],A
    75D7: 55 04 00 MOV   [__r2],0x0
    75DA: 65 03    ASL   [__r3]
    75DC: 6B 04    RLC   [__r2]
    75DE: 65 03    ASL   [__r3]
    75E0: 6B 04    RLC   [__r2]
    75E2: 51 03    MOV   A,[__r3]
    75E4: 02 05    ADD   A,[__r1]
    75E6: 53 05    MOV   [__r1],A
    75E8: 51 04    MOV   A,[__r2]
    75EA: 0A 06    ADC   A,[__r0]
    75EC: 53 06    MOV   [__r0],A
    75EE: 51 05    MOV   A,[__r1]
    75F0: 54 48    MOV   [X+72],A
    75F2: 51 06    MOV   A,[__r0]
    75F4: 54 47    MOV   [X+71],A
(0120) 	   fwStruct.pARG_FlashBuffer = &data[4];	// Data start Address
    75F6: 5A 05    MOV   [__r1],X
    75F8: 06 05 07 ADD   [__r1],0x7
    75FB: 51 05    MOV   A,[__r1]
    75FD: 54 4A    MOV   [X+74],A
    75FF: 56 49 07 MOV   [X+73],0x7
(0121) 	   fwStruct.cARG_Temperature = 25;		// Temperature in Celsius
    7602: 56 4B 19 MOV   [X+75],0x19
(0122) 	   bFlashWriteBlock(&fwStruct);			// Write Block
    7605: 5A 05    MOV   [__r1],X
    7607: 06 05 47 ADD   [__r1],0x47
    760A: 10       PUSH  X
    760B: 50 07    MOV   A,0x7
    760D: 08       PUSH  A
    760E: 51 05    MOV   A,[__r1]
    7610: 5C       MOV   X,A
    7611: 18       POP   A
    7612: 7C 7D 6B LCALL 0x7D6B
    7615: 20       POP   X
    7616: 62 D0 00 MOV   REG[0xD0],0x0
(0123) 
(0124) 	   // Sending Back Written Block for Analyzing
(0125) 	   Boot_UART_PutChar('S');	   // Start frame Symbol
    7619: 50 53    MOV   A,0x53
    761B: 08       PUSH  A
    761C: 9E B6    CALL  _Boot_UART_PutChar
    761E: 38 FF    ADD   SP,0xFF
(0126) 	   for (i=0;i<68;i++){
    7620: 56 01 00 MOV   [X+1],0x0
    7623: 80 69    JMP   0x768D
(0127) 	      ch = data[i]>>4;
    7625: 62 D0 00 MOV   REG[0xD0],0x0
    7628: 55 06 07 MOV   [__r0],0x7
    762B: 5A 05    MOV   [__r1],X
    762D: 06 05 03 ADD   [__r1],0x3
    7630: 52 01    MOV   A,[X+1]
    7632: 02 05    ADD   A,[__r1]
    7634: 53 05    MOV   [__r1],A
    7636: 50 00    MOV   A,0x0
    7638: 0A 06    ADC   A,[__r0]
    763A: 60 D4    MOV   REG[0xD4],A
    763C: 3E 05    MVI   A,[__r1]
    763E: 67       ASR   A
    763F: 67       ASR   A
    7640: 67       ASR   A
    7641: 67       ASR   A
    7642: 21 0F    AND   A,0xF
    7644: 54 00    MOV   [X+0],A
(0128) 	      if (ch>=0x0A) ch+=('a'-10); else ch+='0';
    7646: 3D 00 0A CMP   [X+0],0xA
    7649: C0 06    JC    0x7650
    764B: 07 00 57 ADD   [X+0],0x57
    764E: 80 04    JMP   0x7653
    7650: 07 00 30 ADD   [X+0],0x30
(0129) 	      Boot_UART_PutChar(ch);		// Send High Nibble
    7653: 52 00    MOV   A,[X+0]
    7655: 08       PUSH  A
    7656: 9E 7C    CALL  _Boot_UART_PutChar
    7658: 38 FF    ADD   SP,0xFF
(0130) 	      cl = data[i]&0x0F;
    765A: 62 D0 00 MOV   REG[0xD0],0x0
    765D: 55 06 07 MOV   [__r0],0x7
    7660: 5A 05    MOV   [__r1],X
    7662: 06 05 03 ADD   [__r1],0x3
    7665: 52 01    MOV   A,[X+1]
    7667: 02 05    ADD   A,[__r1]
    7669: 53 05    MOV   [__r1],A
    766B: 50 00    MOV   A,0x0
    766D: 0A 06    ADC   A,[__r0]
    766F: 60 D4    MOV   REG[0xD4],A
    7671: 3E 05    MVI   A,[__r1]
    7673: 21 0F    AND   A,0xF
    7675: 54 02    MOV   [X+2],A
(0131) 	      if (cl>=0x0A) cl+=('a'-10); else cl+='0';
    7677: 3D 02 0A CMP   [X+2],0xA
    767A: C0 06    JC    0x7681
    767C: 07 02 57 ADD   [X+2],0x57
    767F: 80 04    JMP   0x7684
    7681: 07 02 30 ADD   [X+2],0x30
(0132) 	      Boot_UART_PutChar(cl);		// Send Low Nibble
    7684: 52 02    MOV   A,[X+2]
    7686: 08       PUSH  A
    7687: 9E 4B    CALL  _Boot_UART_PutChar
    7689: 38 FF    ADD   SP,0xFF
(0133) 	   }
    768B: 77 01    INC   [X+1]
    768D: 3D 01 44 CMP   [X+1],0x44
    7690: CF 94    JC    0x7625
(0134) 	   Boot_UART_PutChar('F');	   // Last frame Symbol
    7692: 50 46    MOV   A,0x46
    7694: 08       PUSH  A
    7695: 9E 3D    CALL  _Boot_UART_PutChar
    7697: 38 FF    ADD   SP,0xFF
(0135) 	}	
    7699: 8E 8B    JMP   0x7525
(0136) 	
(0137) 	if (LastBlock_To_Check==0) return;	// Don't calculate a checksum
    769B: 62 D0 00 MOV   REG[0xD0],0x0
    769E: 50 73    MOV   A,0x73
    76A0: 10       PUSH  X
    76A1: 57 FE    MOV   X,0xFE
    76A3: 08       PUSH  A
    76A4: 28       ROMX  
    76A5: 53 06    MOV   [__r0],A
    76A7: 18       POP   A
    76A8: 75       INC   X
    76A9: 09 00    ADC   A,0x0
    76AB: 28       ROMX  
    76AC: 20       POP   X
    76AD: 3C 06 00 CMP   [__r0],0x0
    76B0: B0 07    JNZ   0x76B8
    76B2: 39 00    CMP   A,0x0
    76B4: B0 03    JNZ   0x76B8
    76B6: 81 58    JMP   0x780F
(0138) 	BlockID = 456;	// first block where checksum is saved (blocks of CheckSum Area:456,457,458,459,460,461,462,463)
    76B8: 56 53 C8 MOV   [X+83],0xC8
    76BB: 56 52 01 MOV   [X+82],0x1
(0139) 	// Calculate CheckSum and Write It In Flash	
(0140) 	for (j=1;j<=LastBlock_To_Check;j++){
    76BE: 56 50 01 MOV   [X+80],0x1
    76C1: 56 4F 00 MOV   [X+79],0x0
    76C4: 80 83    JMP   0x7748
(0141) 		if ((j&0x3F)==0) {		  
    76C6: 62 D0 00 MOV   REG[0xD0],0x0
    76C9: 52 50    MOV   A,[X+80]
    76CB: 21 3F    AND   A,0x3F
    76CD: 53 05    MOV   [__r1],A
    76CF: 52 4F    MOV   A,[X+79]
    76D1: 21 00    AND   A,0x0
    76D3: 39 00    CMP   A,0x0
    76D5: B0 39    JNZ   0x770F
    76D7: 3C 05 00 CMP   [__r1],0x0
    76DA: B0 34    JNZ   0x770F
(0142) 		  fwStruct.wARG_BlockId = BlockID;       	// Block ID 
    76DC: 52 53    MOV   A,[X+83]
    76DE: 54 48    MOV   [X+72],A
    76E0: 52 52    MOV   A,[X+82]
    76E2: 54 47    MOV   [X+71],A
(0143) 	      fwStruct.pARG_FlashBuffer = &data[0];  	// Data start Address
    76E4: 62 D0 00 MOV   REG[0xD0],0x0
    76E7: 5A 05    MOV   [__r1],X
    76E9: 06 05 03 ADD   [__r1],0x3
    76EC: 51 05    MOV   A,[__r1]
    76EE: 54 4A    MOV   [X+74],A
    76F0: 56 49 07 MOV   [X+73],0x7
(0144) 	      fwStruct.cARG_Temperature = 25;			// Temperature in Celsius
    76F3: 56 4B 19 MOV   [X+75],0x19
(0145) 	      bFlashWriteBlock(&fwStruct);				// Write Block
    76F6: 5A 05    MOV   [__r1],X
    76F8: 06 05 47 ADD   [__r1],0x47
    76FB: 10       PUSH  X
    76FC: 50 07    MOV   A,0x7
    76FE: 08       PUSH  A
    76FF: 51 05    MOV   A,[__r1]
    7701: 5C       MOV   X,A
    7702: 18       POP   A
    7703: 7C 7D 6B LCALL 0x7D6B
    7706: 20       POP   X
    7707: 62 D0 00 MOV   REG[0xD0],0x0
(0146)  		  BlockID++;								// Increment Block ID
    770A: 77 53    INC   [X+83]
    770C: 0F 52 00 ADC   [X+82],0x0
(0147) 		}  
(0148) 		data[j&0x3F] = FlashCheckSum(j);			// data[i%64] <- CheckSum of i-th block
    770F: 52 4F    MOV   A,[X+79]
    7711: 08       PUSH  A
    7712: 52 50    MOV   A,[X+80]
    7714: 08       PUSH  A
    7715: 7C 7D 23 LCALL 0x7D23
    7718: 38 FE    ADD   SP,0xFE
    771A: 62 D0 00 MOV   REG[0xD0],0x0
    771D: 53 06    MOV   [__r0],A
    771F: 55 04 07 MOV   [__r2],0x7
    7722: 5A 03    MOV   [__r3],X
    7724: 06 03 03 ADD   [__r3],0x3
    7727: 52 50    MOV   A,[X+80]
    7729: 21 3F    AND   A,0x3F
    772B: 53 01    MOV   [__r5],A
    772D: 52 4F    MOV   A,[X+79]
    772F: 21 00    AND   A,0x0
    7731: 53 02    MOV   [__r4],A
    7733: 51 01    MOV   A,[__r5]
    7735: 02 03    ADD   A,[__r3]
    7737: 53 03    MOV   [__r3],A
    7739: 51 02    MOV   A,[__r4]
    773B: 0A 04    ADC   A,[__r2]
    773D: 60 D5    MOV   REG[0xD5],A
    773F: 51 06    MOV   A,[__r0]
    7741: 3F 03    MVI   [__r3],A
(0149)     }  
    7743: 77 50    INC   [X+80]
    7745: 0F 4F 00 ADC   [X+79],0x0
    7748: 62 D0 00 MOV   REG[0xD0],0x0
    774B: 50 73    MOV   A,0x73
    774D: 10       PUSH  X
    774E: 57 FE    MOV   X,0xFE
    7750: 08       PUSH  A
    7751: 28       ROMX  
    7752: 53 06    MOV   [__r0],A
    7754: 18       POP   A
    7755: 75       INC   X
    7756: 09 00    ADC   A,0x0
    7758: 28       ROMX  
    7759: 20       POP   X
    775A: 13 50    SUB   A,[X+80]
    775C: 52 4F    MOV   A,[X+79]
    775E: 31 80    XOR   A,0x80
    7760: 53 00    MOV   [__rX],A
    7762: 51 06    MOV   A,[__r0]
    7764: 31 80    XOR   A,0x80
    7766: 1A 00    SBB   A,[__rX]
    7768: DF 5D    JNC   0x76C6
(0150)     fwStruct.wARG_BlockId = BlockID;         		// Block ID 
    776A: 52 53    MOV   A,[X+83]
    776C: 54 48    MOV   [X+72],A
    776E: 52 52    MOV   A,[X+82]
    7770: 54 47    MOV   [X+71],A
(0151)     fwStruct.pARG_FlashBuffer = &data[0];  			// Data start Address
    7772: 62 D0 00 MOV   REG[0xD0],0x0
    7775: 5A 05    MOV   [__r1],X
    7777: 06 05 03 ADD   [__r1],0x3
    777A: 51 05    MOV   A,[__r1]
    777C: 54 4A    MOV   [X+74],A
    777E: 56 49 07 MOV   [X+73],0x7
(0152)     fwStruct.cARG_Temperature = 25;					// Temperature in Celsius
    7781: 56 4B 19 MOV   [X+75],0x19
(0153)     if (BlockID!=463){
    7784: 3D 52 01 CMP   [X+82],0x1
    7787: B0 06    JNZ   0x778E
    7789: 3D 53 CF CMP   [X+83],0xCF
    778C: A0 1E    JZ    0x77AB
(0154)        bFlashWriteBlock(&fwStruct);					// Write Block
    778E: 62 D0 00 MOV   REG[0xD0],0x0
    7791: 5A 05    MOV   [__r1],X
    7793: 06 05 47 ADD   [__r1],0x47
    7796: 10       PUSH  X
    7797: 50 07    MOV   A,0x7
    7799: 08       PUSH  A
    779A: 51 05    MOV   A,[__r1]
    779C: 5C       MOV   X,A
    779D: 18       POP   A
    779E: 7C 7D 6B LCALL 0x7D6B
    77A1: 20       POP   X
    77A2: 62 D0 00 MOV   REG[0xD0],0x0
(0155)        BlockID=463;
    77A5: 56 53 CF MOV   [X+83],0xCF
    77A8: 56 52 01 MOV   [X+82],0x1
(0156)     };
(0157) 
(0158)     data[62]=(char)(LastBlock_To_Check>>8);			// Save last block to check (MSB)
    77AB: 62 D0 00 MOV   REG[0xD0],0x0
    77AE: 50 73    MOV   A,0x73
    77B0: 10       PUSH  X
    77B1: 57 FE    MOV   X,0xFE
    77B3: 08       PUSH  A
    77B4: 28       ROMX  
    77B5: 53 06    MOV   [__r0],A
    77B7: 18       POP   A
    77B8: 75       INC   X
    77B9: 09 00    ADC   A,0x0
    77BB: 28       ROMX  
    77BC: 20       POP   X
    77BD: 51 06    MOV   A,[__r0]
    77BF: 53 05    MOV   [__r1],A
    77C1: 47 05 80 TST   [__r1],0x80
    77C4: B0 06    JNZ   0x77CB
    77C6: 55 06 00 MOV   [__r0],0x0
    77C9: 80 04    JMP   0x77CE
    77CB: 62 D0 00 MOV   REG[0xD0],0x0
    77CE: 62 D0 00 MOV   REG[0xD0],0x0
    77D1: 51 05    MOV   A,[__r1]
    77D3: 54 41    MOV   [X+65],A
(0159)     data[63]=(char)LastBlock_To_Check;				// Save last block to check (LSB)
    77D5: 50 73    MOV   A,0x73
    77D7: 10       PUSH  X
    77D8: 57 FE    MOV   X,0xFE
    77DA: 08       PUSH  A
    77DB: 28       ROMX  
    77DC: 18       POP   A
    77DD: 75       INC   X
    77DE: 09 00    ADC   A,0x0
    77E0: 28       ROMX  
    77E1: 20       POP   X
    77E2: 54 42    MOV   [X+66],A
(0160)     fwStruct.wARG_BlockId = BlockID;         		// Block ID     
    77E4: 52 53    MOV   A,[X+83]
    77E6: 54 48    MOV   [X+72],A
    77E8: 52 52    MOV   A,[X+82]
    77EA: 54 47    MOV   [X+71],A
(0161)     fwStruct.pARG_FlashBuffer = &data[0];  			// Data start Address
    77EC: 5A 05    MOV   [__r1],X
    77EE: 06 05 03 ADD   [__r1],0x3
    77F1: 51 05    MOV   A,[__r1]
    77F3: 54 4A    MOV   [X+74],A
    77F5: 56 49 07 MOV   [X+73],0x7
(0162)     fwStruct.cARG_Temperature = 25;					// Temperature in Celsius
    77F8: 56 4B 19 MOV   [X+75],0x19
(0163)     bFlashWriteBlock(&fwStruct);					// Write Block
    77FB: 5A 05    MOV   [__r1],X
    77FD: 06 05 47 ADD   [__r1],0x47
    7800: 10       PUSH  X
    7801: 50 07    MOV   A,0x7
    7803: 08       PUSH  A
    7804: 51 05    MOV   A,[__r1]
    7806: 5C       MOV   X,A
    7807: 18       POP   A
    7808: 7C 7D 6B LCALL 0x7D6B
    780B: 20       POP   X
    780C: 62 D0 00 MOV   REG[0xD0],0x0
    780F: 38 AC    ADD   SP,0xAC
    7811: 20       POP   X
    7812: 7F       RET   
(0164) }
(0165) 
(0166) void BootLoader(void){
_BootLoader:
  CheckSum             --> X+27
  k                    --> X+26
  j                    --> X+24
  strConnect           --> X+16
  strAnswer            --> X+12
  Error                --> X+11
  buffer               --> X+1
  i                    --> X+0
    7813: 10       PUSH  X
    7814: 4F       MOV   X,SP
    7815: 38 1C    ADD   SP,0x1C
(0167) //    long int x;
(0168) //    char z;
(0169) 	int j;    	
(0170) 	char buffer[10];
(0171) 	char Error,i,k;
(0172) 	char CheckSum;
(0173)     char strConnect[8];//={'C','O','N','N','E','C','T','\0'};
(0174)     char strAnswer[4];//={'O','K','!','\0'};
(0175) 	// Initiate communications Strings:
(0176)     // strConnect[]="CONNECT", // Initiate string form PC
(0177)     // strAnswer[]="OK!";      // Answer to PC
(0178) 	strConnect[0]='C';strConnect[1]='O';strConnect[2]='N';strConnect[3]='N';strConnect[4]='E';
    7817: 56 10 43 MOV   [X+16],0x43
    781A: 56 11 4F MOV   [X+17],0x4F
    781D: 56 12 4E MOV   [X+18],0x4E
    7820: 56 13 4E MOV   [X+19],0x4E
    7823: 56 14 45 MOV   [X+20],0x45
(0179)     strConnect[5]='C';strConnect[6]='T';strConnect[7]=0;
    7826: 56 15 43 MOV   [X+21],0x43
    7829: 56 16 54 MOV   [X+22],0x54
    782C: 56 17 00 MOV   [X+23],0x0
(0180) 	strAnswer[0]='O';strAnswer[1]='K';strAnswer[2]='!';strAnswer[3]=0;
    782F: 56 0C 4F MOV   [X+12],0x4F
    7832: 56 0D 4B MOV   [X+13],0x4B
    7835: 56 0E 21 MOV   [X+14],0x21
    7838: 56 0F 00 MOV   [X+15],0x0
(0181) 
(0182)  	// Initiate UART Module
(0183) 	Boot_RxD_Start(RX8_PARITY_NONE);
    783B: 10       PUSH  X
    783C: 50 00    MOV   A,0x0
    783E: 7C 7C 90 LCALL 0x7C90
(0184) 	Boot_TxD_Start(TX8_PARITY_NONE);
    7841: 50 00    MOV   A,0x0
    7843: 7C 7C 9F LCALL 0x7C9F
    7846: 20       POP   X
(0185) 
(0186) #if ENABLE_CONNECT_BY_PSOC
(0187) 	// Check conditions for remote programming only through UART
(0188) 	// if was Power On Reset then check this
(0189) 	//
(0190) 	if (CPU_SCR0 & CPU_SCR0_PORS_MASK){
    7847: 5D FF    MOV   A,REG[0xFF]
    7849: 62 D0 00 MOV   REG[0xD0],0x0
    784C: 53 06    MOV   [__r0],A
    784E: 47 06 10 TST   [__r0],0x10
    7851: A0 C6    JZ    0x7918
(0191)       	Boot_UART_CPutString(strConnect);	// Send Connect Message to PC
    7853: 5A 05    MOV   [__r1],X
    7855: 06 05 10 ADD   [__r1],0x10
    7858: 50 07    MOV   A,0x7
    785A: 08       PUSH  A
    785B: 51 05    MOV   A,[__r1]
    785D: 08       PUSH  A
    785E: 9C 8E    CALL  _Boot_UART_CPutString
    7860: 38 FE    ADD   SP,0xFE
(0192)       	Boot_Counter_DisableInt();	// Disable Counter Interrupts
    7862: 10       PUSH  X
    7863: 7C 7C AA LCALL 0x7CAA
(0193)       	Boot_Counter_WritePeriod(8191);	// a half second timeout (Counter Clock=32kHz)
    7866: 57 1F    MOV   X,0x1F
    7868: 50 FF    MOV   A,0xFF
    786A: 7C 7C B2 LCALL 0x7CB2
(0194)       	Boot_Counter_WriteCompareValue(4094);// compare value
    786D: 57 0F    MOV   X,0xF
    786F: 50 FE    MOV   A,0xFE
    7871: 7C 7C B8 LCALL 0x7CB8
(0195)       	Boot_Counter_Start();		// Start Counter
    7874: 7C 7C AE LCALL 0x7CAE
    7877: 20       POP   X
(0196)       	k=0;
    7878: 56 1A 00 MOV   [X+26],0x0
    787B: 80 84    JMP   0x7900
(0197)       	while (Boot_Counter_wReadCounter()!=0){	// Timeout - a half second
(0198) 	       if (Boot_RxD_bReadRxStatus() & RX8_RX_COMPLETE){ // if character was got by RxD
    787D: 10       PUSH  X
    787E: 7C 7C 9C LCALL 0x7C9C
    7881: 20       POP   X
    7882: 62 D0 00 MOV   REG[0xD0],0x0
    7885: 53 06    MOV   [__r0],A
    7887: 47 06 08 TST   [__r0],0x8
    788A: A0 59    JZ    0x78E4
(0199) 	           buffer[k]=Boot_RxD_bReadRxData();		// then read this character
    788C: 10       PUSH  X
    788D: 7C 7C 99 LCALL 0x7C99
    7890: 20       POP   X
    7891: 62 D0 00 MOV   REG[0xD0],0x0
    7894: 53 06    MOV   [__r0],A
    7896: 55 04 07 MOV   [__r2],0x7
    7899: 5A 03    MOV   [__r3],X
    789B: 06 03 01 ADD   [__r3],0x1
    789E: 52 1A    MOV   A,[X+26]
    78A0: 02 03    ADD   A,[__r3]
    78A2: 53 03    MOV   [__r3],A
    78A4: 50 00    MOV   A,0x0
    78A6: 0A 04    ADC   A,[__r2]
    78A8: 60 D5    MOV   REG[0xD5],A
    78AA: 51 06    MOV   A,[__r0]
    78AC: 3F 03    MVI   [__r3],A
(0200) 	           if (buffer[k]==strAnswer[k]) k++;	// if match then go on
    78AE: 55 06 07 MOV   [__r0],0x7
    78B1: 5A 05    MOV   [__r1],X
    78B3: 06 05 0C ADD   [__r1],0xC
    78B6: 52 1A    MOV   A,[X+26]
    78B8: 02 05    ADD   A,[__r1]
    78BA: 53 05    MOV   [__r1],A
    78BC: 50 00    MOV   A,0x0
    78BE: 0A 06    ADC   A,[__r0]
    78C0: 60 D4    MOV   REG[0xD4],A
    78C2: 3E 05    MVI   A,[__r1]
    78C4: 53 06    MOV   [__r0],A
    78C6: 5A 03    MOV   [__r3],X
    78C8: 06 03 01 ADD   [__r3],0x1
    78CB: 52 1A    MOV   A,[X+26]
    78CD: 02 03    ADD   A,[__r3]
    78CF: 53 03    MOV   [__r3],A
    78D1: 50 00    MOV   A,0x0
    78D3: 0A 04    ADC   A,[__r2]
    78D5: 60 D4    MOV   REG[0xD4],A
    78D7: 3E 03    MVI   A,[__r3]
    78D9: 3A 06    CMP   A,[__r0]
    78DB: B0 05    JNZ   0x78E1
    78DD: 77 1A    INC   [X+26]
    78DF: 80 04    JMP   0x78E4
(0201) 	             else k=0;							// Start receiving symbol from the beginning
    78E1: 56 1A 00 MOV   [X+26],0x0
(0202) 	       }
(0203) 	       if (k==3) {
    78E4: 3D 1A 03 CMP   [X+26],0x3
    78E7: B0 18    JNZ   0x7900
(0204) 	         Boot_UART_CPutString(strAnswer);	// send back strAnswer to establish connection
    78E9: 62 D0 00 MOV   REG[0xD0],0x0
    78EC: 5A 05    MOV   [__r1],X
    78EE: 06 05 0C ADD   [__r1],0xC
    78F1: 50 07    MOV   A,0x7
    78F3: 08       PUSH  A
    78F4: 51 05    MOV   A,[__r1]
    78F6: 08       PUSH  A
    78F7: 9B F5    CALL  _Boot_UART_CPutString
    78F9: 38 FE    ADD   SP,0xFE
(0205)       	     Boot_PerformWrite();			// reprogram Flash
    78FB: 9C 1F    CALL  _Boot_PerformWrite
(0206)     	     M8C_Reset;						// Perform Software Reset by Supervisory Call      	   
    78FD: 50 00    MOV   A,0x0
    78FF: 00       SWI   
(0207) 	       }  
(0208)       	};
    7900: 10       PUSH  X
    7901: 7C 7C BE LCALL 0x7CBE
    7904: 62 D0 00 MOV   REG[0xD0],0x0
    7907: 5A 06    MOV   [__r0],X
    7909: 20       POP   X
    790A: 3C 06 00 CMP   [__r0],0x0
    790D: BF 6F    JNZ   0x787D
    790F: 39 00    CMP   A,0x0
    7911: BF 6B    JNZ   0x787D
(0209)       	Boot_Counter_Stop();				// Stop Counter
    7913: 10       PUSH  X
    7914: 7C 7C 95 LCALL 0x7C95
    7917: 20       POP   X
(0210) 	}
(0211) #endif
(0212) 
(0213) 	// Control if a BoootLoader Program is correct 
(0214) 	Error=0;
    7918: 56 0B 00 MOV   [X+11],0x0
(0215) 	if (!Boot_Is_Program_Good()) Error=1;
    791B: 7C 7C FC LCALL 0x7CFC
    791E: 62 D0 00 MOV   REG[0xD0],0x0
    7921: 39 00    CMP   A,0x0
    7923: B0 04    JNZ   0x7928
    7925: 56 0B 01 MOV   [X+11],0x1
(0216) 	// Control CheckSum if needed
(0217) 	if (LastBlock_To_Check!=0) {	// Don't calculate checksum if 0
    7928: 62 D0 00 MOV   REG[0xD0],0x0
    792B: 50 73    MOV   A,0x73
    792D: 10       PUSH  X
    792E: 57 FE    MOV   X,0xFE
    7930: 08       PUSH  A
    7931: 28       ROMX  
    7932: 53 06    MOV   [__r0],A
    7934: 18       POP   A
    7935: 75       INC   X
    7936: 09 00    ADC   A,0x0
    7938: 28       ROMX  
    7939: 20       POP   X
    793A: 3C 06 00 CMP   [__r0],0x0
    793D: B0 05    JNZ   0x7943
    793F: 39 00    CMP   A,0x0
    7941: A0 5D    JZ    0x799F
(0218)       for (j=1;j<=LastBlock_To_Check;j++){
    7943: 56 19 01 MOV   [X+25],0x1
    7946: 56 18 00 MOV   [X+24],0x0
    7949: 80 33    JMP   0x797D
(0219)          CheckSum=BootCheckSumBlock[j];
    794B: 62 D0 00 MOV   REG[0xD0],0x0
    794E: 52 19    MOV   A,[X+25]
    7950: 01 00    ADD   A,0x0
    7952: 53 05    MOV   [__r1],A
    7954: 52 18    MOV   A,[X+24]
    7956: 09 72    ADC   A,0x72
    7958: 10       PUSH  X
    7959: 58 05    MOV   X,[__r1]
    795B: 28       ROMX  
    795C: 20       POP   X
    795D: 54 1B    MOV   [X+27],A
(0220)          if (CheckSum!=FlashCheckSum(j)) Error=1;	// Set CheckSum Error Flag
    795F: 52 18    MOV   A,[X+24]
    7961: 08       PUSH  A
    7962: 52 19    MOV   A,[X+25]
    7964: 08       PUSH  A
    7965: 7C 7D 23 LCALL 0x7D23
    7968: 38 FE    ADD   SP,0xFE
    796A: 62 D0 00 MOV   REG[0xD0],0x0
    796D: 53 06    MOV   [__r0],A
    796F: 52 1B    MOV   A,[X+27]
    7971: 3A 06    CMP   A,[__r0]
    7973: A0 04    JZ    0x7978
    7975: 56 0B 01 MOV   [X+11],0x1
(0221)       }  
    7978: 77 19    INC   [X+25]
    797A: 0F 18 00 ADC   [X+24],0x0
    797D: 62 D0 00 MOV   REG[0xD0],0x0
    7980: 50 73    MOV   A,0x73
    7982: 10       PUSH  X
    7983: 57 FE    MOV   X,0xFE
    7985: 08       PUSH  A
    7986: 28       ROMX  
    7987: 53 06    MOV   [__r0],A
    7989: 18       POP   A
    798A: 75       INC   X
    798B: 09 00    ADC   A,0x0
    798D: 28       ROMX  
    798E: 20       POP   X
    798F: 13 19    SUB   A,[X+25]
    7991: 52 18    MOV   A,[X+24]
    7993: 31 80    XOR   A,0x80
    7995: 53 00    MOV   [__rX],A
    7997: 51 06    MOV   A,[__r0]
    7999: 31 80    XOR   A,0x80
    799B: 1A 00    SBB   A,[__rX]
    799D: DF AD    JNC   0x794B
(0222)     }  
(0223)     // Check button to enter bootloader mode
(0224) //    SETBUTTON();		// pull up for Button
(0225)     if (!GETBUTTON()) 
    799F: 5D 00    MOV   A,REG[0x0]
    79A1: 62 D0 00 MOV   REG[0xD0],0x0
    79A4: 53 06    MOV   [__r0],A
    79A6: 47 06 20 TST   [__r0],0x20
    79A9: B0 09    JNZ   0x79B3
(0226)       if (!Error) asm("ljmp __Start");	// if button not pressed - Start Firmwire
    79AB: 3D 0B 00 CMP   [X+11],0x0
    79AE: B0 04    JNZ   0x79B3
    79B0: 7D 00 A6 LJMP  0x00A6
(0227) 			
(0228)     // Here it communicates with PC and then starts programming
(0229) 	BOOTLOADER_MODE_LED_ON();		// light on LED when entered BootLoader Mode
    79B3: 43 04 80 OR    REG[0x4],0x80
(0230) 		
(0231)  	// Connect with PC Terminal Program
(0232) 	Error=1;
    79B6: 56 0B 01 MOV   [X+11],0x1
    79B9: 80 DB    JMP   0x7A95
(0233) 	// Set Communication here
(0234) 	while (Error){
(0235) 	 	Error=0;
    79BB: 56 0B 00 MOV   [X+11],0x0
(0236) 	 	for (i=0;i<7; i++) {
    79BE: 56 00 00 MOV   [X+0],0x0
    79C1: 80 56    JMP   0x7A18
(0237) 	 	  buffer[i]=Boot_UART_cGetChar();
    79C3: 9A E9    CALL  _Boot_UART_cGetChar
    79C5: 62 D0 00 MOV   REG[0xD0],0x0
    79C8: 53 06    MOV   [__r0],A
    79CA: 55 04 07 MOV   [__r2],0x7
    79CD: 5A 03    MOV   [__r3],X
    79CF: 06 03 01 ADD   [__r3],0x1
    79D2: 52 00    MOV   A,[X+0]
    79D4: 02 03    ADD   A,[__r3]
    79D6: 53 03    MOV   [__r3],A
    79D8: 50 00    MOV   A,0x0
    79DA: 0A 04    ADC   A,[__r2]
    79DC: 60 D5    MOV   REG[0xD5],A
    79DE: 51 06    MOV   A,[__r0]
    79E0: 3F 03    MVI   [__r3],A
(0238) 	 	  if (buffer[i]!=*(strConnect+i)) { 
    79E2: 55 06 07 MOV   [__r0],0x7
    79E5: 5A 05    MOV   [__r1],X
    79E7: 06 05 10 ADD   [__r1],0x10
    79EA: 52 00    MOV   A,[X+0]
    79EC: 02 05    ADD   A,[__r1]
    79EE: 53 05    MOV   [__r1],A
    79F0: 50 00    MOV   A,0x0
    79F2: 0A 06    ADC   A,[__r0]
    79F4: 60 D4    MOV   REG[0xD4],A
    79F6: 3E 05    MVI   A,[__r1]
    79F8: 53 06    MOV   [__r0],A
    79FA: 5A 03    MOV   [__r3],X
    79FC: 06 03 01 ADD   [__r3],0x1
    79FF: 52 00    MOV   A,[X+0]
    7A01: 02 03    ADD   A,[__r3]
    7A03: 53 03    MOV   [__r3],A
    7A05: 50 00    MOV   A,0x0
    7A07: 0A 04    ADC   A,[__r2]
    7A09: 60 D4    MOV   REG[0xD4],A
    7A0B: 3E 03    MVI   A,[__r3]
    7A0D: 3A 06    CMP   A,[__r0]
    7A0F: A0 06    JZ    0x7A16
(0239) 	 	       Error=1;
    7A11: 56 0B 01 MOV   [X+11],0x1
(0240) 	 	       break;
    7A14: 80 08    JMP   0x7A1D
(0241) 	 	  }
(0242) 	 	}
    7A16: 77 00    INC   [X+0]
    7A18: 3D 00 07 CMP   [X+0],0x7
    7A1B: CF A7    JC    0x79C3
(0243) 	 	if (Error) continue;
    7A1D: 3D 0B 00 CMP   [X+11],0x0
    7A20: A0 03    JZ    0x7A24
    7A22: 80 72    JMP   0x7A95
(0244) 	
(0245) 	    // Send Back Annswer - "Ok!"
(0246)       	Boot_UART_CPutString(strAnswer);
    7A24: 62 D0 00 MOV   REG[0xD0],0x0
    7A27: 5A 05    MOV   [__r1],X
    7A29: 06 05 0C ADD   [__r1],0xC
    7A2C: 50 07    MOV   A,0x7
    7A2E: 08       PUSH  A
    7A2F: 51 05    MOV   A,[__r1]
    7A31: 08       PUSH  A
    7A32: 9A BA    CALL  _Boot_UART_CPutString
    7A34: 38 FE    ADD   SP,0xFE
(0247)     	// Get Answer back -"Ok!"
(0248)     	for (i=0;i<3; i++) {
    7A36: 56 00 00 MOV   [X+0],0x0
    7A39: 80 56    JMP   0x7A90
(0249) 	 	  buffer[i]=Boot_UART_cGetChar();
    7A3B: 9A 71    CALL  _Boot_UART_cGetChar
    7A3D: 62 D0 00 MOV   REG[0xD0],0x0
    7A40: 53 06    MOV   [__r0],A
    7A42: 55 04 07 MOV   [__r2],0x7
    7A45: 5A 03    MOV   [__r3],X
    7A47: 06 03 01 ADD   [__r3],0x1
    7A4A: 52 00    MOV   A,[X+0]
    7A4C: 02 03    ADD   A,[__r3]
    7A4E: 53 03    MOV   [__r3],A
    7A50: 50 00    MOV   A,0x0
    7A52: 0A 04    ADC   A,[__r2]
    7A54: 60 D5    MOV   REG[0xD5],A
    7A56: 51 06    MOV   A,[__r0]
    7A58: 3F 03    MVI   [__r3],A
(0250) 	 	  if (buffer[i]!=*(strAnswer+i)) { 
    7A5A: 55 06 07 MOV   [__r0],0x7
    7A5D: 5A 05    MOV   [__r1],X
    7A5F: 06 05 0C ADD   [__r1],0xC
    7A62: 52 00    MOV   A,[X+0]
    7A64: 02 05    ADD   A,[__r1]
    7A66: 53 05    MOV   [__r1],A
    7A68: 50 00    MOV   A,0x0
    7A6A: 0A 06    ADC   A,[__r0]
    7A6C: 60 D4    MOV   REG[0xD4],A
    7A6E: 3E 05    MVI   A,[__r1]
    7A70: 53 06    MOV   [__r0],A
    7A72: 5A 03    MOV   [__r3],X
    7A74: 06 03 01 ADD   [__r3],0x1
    7A77: 52 00    MOV   A,[X+0]
    7A79: 02 03    ADD   A,[__r3]
    7A7B: 53 03    MOV   [__r3],A
    7A7D: 50 00    MOV   A,0x0
    7A7F: 0A 04    ADC   A,[__r2]
    7A81: 60 D4    MOV   REG[0xD4],A
    7A83: 3E 03    MVI   A,[__r3]
    7A85: 3A 06    CMP   A,[__r0]
    7A87: A0 06    JZ    0x7A8E
(0251) 	 	       Error=1;
    7A89: 56 0B 01 MOV   [X+11],0x1
(0252) 	 	       break;
    7A8C: 80 08    JMP   0x7A95
(0253) 	 	  }
(0254) 	 	}
    7A8E: 77 00    INC   [X+0]
    7A90: 3D 00 03 CMP   [X+0],0x3
    7A93: CF A7    JC    0x7A3B
(0255) 	}
    7A95: 3D 0B 00 CMP   [X+11],0x0
    7A98: BF 22    JNZ   0x79BB
(0256) 	
(0257) 	// Waiting for blocks to be written
(0258) 	Boot_PerformWrite();
    7A9A: 9A 80    CALL  _Boot_PerformWrite
(0259) 	
(0260) 	M8C_Reset;		// Perform Software Reset by Supervisory Call
    7A9C: 50 00    MOV   A,0x0
    7A9E: 00       SWI   
    7A9F: 38 E4    ADD   SP,0xE4
    7AA1: 20       POP   X
    7AA2: 7F       RET   
FILE: .\bootloaderconfig.asm            (0001) ;********************************************************************************
                                        (0002) ; Cypress Semiconductor Corporation
                                        (0003) ; Cypress’ Source Code: Copyright 2010, Cypress Semiconductor Corporation.
                                        (0004) ; This Source Code (software and*or firmware) is owned by Cypress Semiconductor
                                        (0005) ; Corporation (Cypress) and is protected by and subject to worldwide patent 
                                        (0006) ; protection (United States and foreign), United States copyright laws and 
                                        (0007) ; international treaty provisions. Cypress hereby grants to licensee a personal,
                                        (0008) ; non-exclusive, non-transferable license to copy, use, modify, create 
                                        (0009) ; derivative works of, and compile the Cypress Source Code and derivative works
                                        (0010) ; for the sole purpose of creating custom software and or firmware in support
                                        (0011) ; of licensee product to be used only in conjunction with a Cypress integrated
                                        (0012) ; circuit as specified in the applicable agreement. Any reproduction,
                                        (0013) ; modification, translation, compilation, or representation of this Source Code
                                        (0014) ; except as specified above is prohibited without the express written
                                        (0015) ; permission of Cypress. 
                                        (0016) ; Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
                                        (0017) ; REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
                                        (0018) ; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
                                        (0019) ; Cypress reserves the right to make changes without further notice to the
                                        (0020) ; materials described herein. Cypress does not assume any liability arising
                                        (0021) ; out of the application or use of any product or circuit described herein.
                                        (0022) ; Cypress does not authorize its products for use as critical components in
                                        (0023) ; life-support systems where a malfunction or failure may reasonably be expected
                                        (0024) ; to result in significant injury to the user. The inclusion of Cypress’ product
                                        (0025) ; in a life-support systems application implies that the manufacturer assumes
                                        (0026) ; all risk of such use and in doing so indemnifies Cypress against all charges.
                                        (0027) ;
                                        (0028) ; Use may be limited by and subject to the applicable Cypress software license
                                        (0029) ; agreement.
                                        (0030) ;
                                        (0031) ;********************************************************************************
                                        (0032) 
                                        (0033) include "m8c.inc"
                                        (0034) include "GlobalParams.inc"
                                        (0035) include "bootloader.inc"
                                        (0036) include "memory.inc"		;File generated by PSoC Designer (Project dependent)
                                        (0037) 
                                        (0038) 
                                        (0039) ;-----------------------------------------------
                                        (0040) ;  Global Symbols
                                        (0041) ;-----------------------------------------------
                                        (0042) export   Boot_RxD_Start
                                        (0043) export  _Boot_RxD_Start
                                        (0044) export   Boot_RxD_bReadRxData
                                        (0045) export  _Boot_RxD_bReadRxData
                                        (0046) export   Boot_RxD_bReadRxStatus
                                        (0047) export  _Boot_RxD_bReadRxStatus
                                        (0048) 
                                        (0049) export   Boot_TxD_Start
                                        (0050) export  _Boot_TxD_Start
                                        (0051) export   Boot_TxD_SendData
                                        (0052) export  _Boot_TxD_SendData
                                        (0053) export   Boot_TxD_bReadTxStatus
                                        (0054) export  _Boot_TxD_bReadTxStatus
                                        (0055) 
                                        (0056) export  Boot_Counter_DisableInt
                                        (0057) export _Boot_Counter_DisableInt
                                        (0058) export  Boot_Counter_Start
                                        (0059) export _Boot_Counter_Start
                                        (0060) export  Boot_Counter_Stop
                                        (0061) export _Boot_Counter_Stop
                                        (0062) export  Boot_Counter_WritePeriod
                                        (0063) export _Boot_Counter_WritePeriod
                                        (0064) export  Boot_Counter_WriteCompareValue
                                        (0065) export _Boot_Counter_WriteCompareValue
                                        (0066) export  Boot_Counter_wReadCounter
                                        (0067) export _Boot_Counter_wReadCounter
                                        (0068) 
                                        (0069) 
                                        (0070) 
                                        (0071) 
                                        (0072) //---------------------------------------------------------------------------------
                                        (0073) // Configuration
                                        (0074) //---------------------------------------------------------------------------------
                                        (0075) 
                                        (0076) export Boot_LoadConfigInit
                                        (0077) export _Boot_LoadConfigInit
                                        (0078) 
                                        (0079) //export NO_SHADOW
                                        (0080) //export _NO_SHADOW
                                        (0081) 
                                        (0082) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0083) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0084) 
                                        (0085) IF	(TOOLCHAIN & HITECH)
                                        (0086) psect BootLoaderArea global
                                        (0087) ELSE
                                        (0088) Area BootLoaderArea(ROM,REL,CON)
                                        (0089) ENDIF
                                        (0090) 
                                        (0091) ;---------------------------------------------------------------------------
                                        (0092) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0093) ;                  parameters handled by boot code, like CPU speed). This
                                        (0094) ;                  function can be called from user code, but typically it
                                        (0095) ;                  is only called from boot.
                                        (0096) ;
                                        (0097) ;       INPUTS: None.
                                        (0098) ;      RETURNS: Nothing.
                                        (0099) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0100) ;               In the large memory model currently only the page
                                        (0101) ;               pointer registers listed below are modified.  This does
                                        (0102) ;               not guarantee that in future implementations of this
                                        (0103) ;               function other page pointer registers will not be
                                        (0104) ;               modified.
                                        (0105) ;          
                                        (0106) ;               Page Pointer Registers Modified: 
                                        (0107) ;               CUR_PP
                                        (0108) ;
                                        (0109) _Boot_LoadConfigInit:
                                        (0110)  Boot_LoadConfigInit:
                                        (0111)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0112)     
7AA3: 7C 7B 03 LCALL 0x7B03             (0113) 	lcall	LoadConfigTBL_bootloader_cy8c29_Ordered
7AA6: 7C 7A AA LCALL 0x7AAA             (0114) 	lcall	LoadConfig_bootloader_cy8c29
                                        (0115) 
                                        (0116)     RAM_EPILOGUE RAM_USE_CLASS_4
7AA9: 7F       RET                      (0117)     ret
                                        (0118) 
                                        (0119) ;---------------------------------------------------------------------------
                                        (0120) ; Load Configuration bootloader_cy8c29
                                        (0121) ;
                                        (0122) ;    Load configuration registers for bootloader_cy8c29.
                                        (0123) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0124) ;
                                        (0125) ;       INPUTS: None.
                                        (0126) ;      RETURNS: Nothing.
                                        (0127) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0128) ;               modified as may the Page Pointer registers!
                                        (0129) ;               In the large memory model currently only the page
                                        (0130) ;               pointer registers listed below are modified.  This does
                                        (0131) ;               not guarantee that in future implementations of this
                                        (0132) ;               function other page pointer registers will not be
                                        (0133) ;               modified.
                                        (0134) ;          
                                        (0135) ;               Page Pointer Registers Modified: 
                                        (0136) ;               CUR_PP
                                        (0137) ;
                                        (0138) _LoadConfig_bootloader_cy8c29:
                                        (0139)  LoadConfig_bootloader_cy8c29:
                                        (0140)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0141) 
7AAA: 10       PUSH  X                  (0142) 	push	x
7AAB: 70 EF    AND   F,0xEF             
                                        (0143)     M8C_SetBank0                    ; Force bank 0
7AAD: 50 00    MOV   A,0x0              (0144)     mov     a, 0                    ; Specify bank 0
7AAF: 67       ASR   A                  (0145)     asr     a                       ; Store in carry flag
                                        (0146)                                     ; Load bank 0 table:
7AB0: 50 7B    MOV   A,0x7B             (0147)     mov     A, >LoadConfigTBL_bootloader_cy8c29_Bank0
7AB2: 57 EC    MOV   X,0xEC             (0148)     mov     X, <LoadConfigTBL_bootloader_cy8c29_Bank0
7AB4: 7C 7A C3 LCALL 0x7AC3             (0149)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0150) 
7AB7: 50 01    MOV   A,0x1              (0151)     mov     a, 1                    ; Specify bank 1
7AB9: 67       ASR   A                  (0152)     asr     a                       ; Store in carry flag
                                        (0153)                                     ; Load bank 1 table:
7ABA: 50 7C    MOV   A,0x7C             (0154)     mov     A, >LoadConfigTBL_bootloader_cy8c29_Bank1
7ABC: 57 53    MOV   X,0x53             (0155)     mov     X, <LoadConfigTBL_bootloader_cy8c29_Bank1
7ABE: 7C 7A C3 LCALL 0x7AC3             (0156)     lcall   LoadConfig              ; Load the bank 1 values
                                        (0157) 
7AC1: 20       POP   X                  (0158) 	pop		x
                                        (0159) 
                                        (0160)     RAM_EPILOGUE RAM_USE_CLASS_4
7AC2: 7F       RET                      (0161)     ret
                                        (0162) 
                                        (0163) 
                                        (0164) 
                                        (0165) 
                                        (0166) ;---------------------------------------------------------------------------
                                        (0167) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0168) ;              pairs. Terminate on address=0xFF.
                                        (0169) ;
                                        (0170) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0171) ;           Flag Register Carry bit encodes the Register Bank
                                        (0172) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0173) ;
                                        (0174) ;  RETURNS: nothing.
                                        (0175) ;
                                        (0176) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0177) ;                X-3 Temporary store for register address
                                        (0178) ;                X-2 LSB of config table address
                                        (0179) ;                X-1 MSB of config table address
                                        (0180) ;
                                        (0181) LoadConfig:
                                        (0182)     RAM_PROLOGUE RAM_USE_CLASS_2
7AC3: 38 02    ADD   SP,0x2             (0183)     add     SP, 2                   ; Set up local vars
7AC5: 10       PUSH  X                  (0184)     push    X                       ; Save config table address on stack
7AC6: 08       PUSH  A                  (0185)     push    A
7AC7: 4F       MOV   X,SP               (0186)     mov     X, SP
7AC8: 56 FC 00 MOV   [X-4],0x0          (0187)     mov     [X-4], 0                ; Set default Destination to Bank 0
7ACB: D0 04    JNC   0x7AD0             (0188)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
7ACD: 56 FC 01 MOV   [X-4],0x1          (0189)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0190) .BankSelectSaved:
7AD0: 18       POP   A                  (0191)     pop     A
7AD1: 20       POP   X                  (0192)     pop     X
7AD2: 70 EF    AND   F,0xEF             
7AD4: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0193) 
                                        (0194) LoadConfigLp:
                                        (0195)     M8C_SetBank0                    ; Switch to bank 0
                                        (0196)     M8C_ClearWDT                    ; Clear the watchdog for long inits
7AD7: 10       PUSH  X                  (0197)     push    X                       ; Preserve the config table address
7AD8: 08       PUSH  A                  (0198)     push    A
7AD9: 28       ROMX                     (0199)     romx                            ; Load register address from table
7ADA: 39 FF    CMP   A,0xFF             (0200)     cmp     A, END_CONFIG_TABLE     ; End of table?
7ADC: A0 1F    JZ    0x7AFC             (0201)     jz      EndLoadConfig           ;   Yes, go wrap it up
7ADE: 4F       MOV   X,SP               (0202)     mov     X, SP                   ;
7ADF: 48 FC 01 TST   [X-4],0x1          (0203)     tst     [X-4], 1                ; Loading IO Bank 1?
7AE2: A0 03    JZ    0x7AE6             (0204)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
7AE4: 71 10    OR    F,0x10             
                                        (0205)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0206) .IOBankNowSet:
7AE6: 54 FD    MOV   [X-3],A            (0207)     mov     [X-3], A                ; Stash the register address
7AE8: 18       POP   A                  (0208)     pop     A                       ; Retrieve the table address
7AE9: 20       POP   X                  (0209)     pop     X
7AEA: 75       INC   X                  (0210)     inc     X                       ; Advance to the data byte
7AEB: 09 00    ADC   A,0x0              (0211)     adc     A, 0
7AED: 10       PUSH  X                  (0212)     push    X                       ; Save the config table address again
7AEE: 08       PUSH  A                  (0213)     push    A
7AEF: 28       ROMX                     (0214)     romx                            ; load config data from the table
7AF0: 4F       MOV   X,SP               (0215)     mov     X, SP                   ; retrieve the register address
7AF1: 59 FD    MOV   X,[X-3]            (0216)     mov     X, [X-3]
7AF3: 61 00    MOV   REG[X+0x0],A       (0217)     mov     reg[X], A               ; Configure the register
7AF5: 18       POP   A                  (0218)     pop     A                       ; retrieve the table address
7AF6: 20       POP   X                  (0219)     pop     X
7AF7: 75       INC   X                  (0220)     inc     X                       ; advance to next table entry
7AF8: 09 00    ADC   A,0x0              (0221)     adc     A, 0
7AFA: 8F D7    JMP   0x7AD2             (0222)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0223) EndLoadConfig:
7AFC: 38 FC    ADD   SP,0xFC            (0224)     add     SP, -4
7AFE: 70 3F    AND   F,0x3F             
7B00: 71 C0    OR    F,0xC0             
                                        (0225)     RAM_EPILOGUE RAM_USE_CLASS_2
7B02: 7F       RET                      (0226)     ret
7B03: 71 10    OR    F,0x10             
                                        (0227) 
                                        (0228) LoadConfigTBL_bootloader_cy8c29_Ordered:
                                        (0229) ;  Ordered Global Register values
                                        (0230) 	M8C_SetBank1
7B05: 62 00 10 MOV   REG[0x0],0x10      (0231) 	mov	reg[00h], 10h		; Port_0_DriveMode_0 register (PRT0DM0)
7B08: 62 01 CF MOV   REG[0x1],0xCF      (0232) 	mov	reg[01h], cfh		; Port_0_DriveMode_1 register (PRT0DM1)
7B0B: 70 EF    AND   F,0xEF             
                                        (0233) 	M8C_SetBank0
7B0D: 62 03 8F MOV   REG[0x3],0x8F      (0234) 	mov	reg[03h], 8fh		; Port_0_DriveMode_2 register (PRT0DM2)
7B10: 62 02 50 MOV   REG[0x2],0x50      (0235) 	mov	reg[02h], 50h		; Port_0_GlobalSelect register (PRT0GS)
7B13: 71 10    OR    F,0x10             
                                        (0236) 	M8C_SetBank1
7B15: 62 02 00 MOV   REG[0x2],0x0       (0237) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
7B18: 62 03 00 MOV   REG[0x3],0x0       (0238) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
7B1B: 70 EF    AND   F,0xEF             
                                        (0239) 	M8C_SetBank0
7B1D: 62 01 00 MOV   REG[0x1],0x0       (0240) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
7B20: 71 10    OR    F,0x10             
                                        (0241) 	M8C_SetBank1
7B22: 62 04 80 MOV   REG[0x4],0x80      (0242) 	mov	reg[04h], 80h		; Port_1_DriveMode_0 register (PRT1DM0)
7B25: 62 05 7F MOV   REG[0x5],0x7F      (0243) 	mov	reg[05h], 7fh		; Port_1_DriveMode_1 register (PRT1DM1)
7B28: 70 EF    AND   F,0xEF             
                                        (0244) 	M8C_SetBank0
7B2A: 62 07 7F MOV   REG[0x7],0x7F      (0245) 	mov	reg[07h], 7fh		; Port_1_DriveMode_2 register (PRT1DM2)
7B2D: 62 06 00 MOV   REG[0x6],0x0       (0246) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
7B30: 71 10    OR    F,0x10             
                                        (0247) 	M8C_SetBank1
7B32: 62 06 00 MOV   REG[0x6],0x0       (0248) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
7B35: 62 07 00 MOV   REG[0x7],0x0       (0249) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
7B38: 70 EF    AND   F,0xEF             
                                        (0250) 	M8C_SetBank0
7B3A: 62 05 00 MOV   REG[0x5],0x0       (0251) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
7B3D: 71 10    OR    F,0x10             
                                        (0252) 	M8C_SetBank1
7B3F: 62 08 00 MOV   REG[0x8],0x0       (0253) 	mov	reg[08h], 00h		; Port_2_DriveMode_0 register (PRT2DM0)
7B42: 62 09 FF MOV   REG[0x9],0xFF      (0254) 	mov	reg[09h], ffh		; Port_2_DriveMode_1 register (PRT2DM1)
7B45: 70 EF    AND   F,0xEF             
                                        (0255) 	M8C_SetBank0
7B47: 62 0B FF MOV   REG[0xB],0xFF      (0256) 	mov	reg[0bh], ffh		; Port_2_DriveMode_2 register (PRT2DM2)
7B4A: 62 0A 00 MOV   REG[0xA],0x0       (0257) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
7B4D: 71 10    OR    F,0x10             
                                        (0258) 	M8C_SetBank1
7B4F: 62 0A 00 MOV   REG[0xA],0x0       (0259) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
7B52: 62 0B 00 MOV   REG[0xB],0x0       (0260) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
7B55: 70 EF    AND   F,0xEF             
                                        (0261) 	M8C_SetBank0
7B57: 62 09 00 MOV   REG[0x9],0x0       (0262) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
7B5A: 71 10    OR    F,0x10             
                                        (0263) 	M8C_SetBank1
7B5C: 62 0C 00 MOV   REG[0xC],0x0       (0264) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
7B5F: 62 0D 00 MOV   REG[0xD],0x0       (0265) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
7B62: 70 EF    AND   F,0xEF             
                                        (0266) 	M8C_SetBank0
7B64: 62 0F 00 MOV   REG[0xF],0x0       (0267) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
7B67: 62 0E 00 MOV   REG[0xE],0x0       (0268) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
7B6A: 71 10    OR    F,0x10             
                                        (0269) 	M8C_SetBank1
7B6C: 62 0E 00 MOV   REG[0xE],0x0       (0270) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
7B6F: 62 0F 00 MOV   REG[0xF],0x0       (0271) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
7B72: 70 EF    AND   F,0xEF             
                                        (0272) 	M8C_SetBank0
7B74: 62 0D 00 MOV   REG[0xD],0x0       (0273) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
7B77: 71 10    OR    F,0x10             
                                        (0274) 	M8C_SetBank1
7B79: 62 10 00 MOV   REG[0x10],0x0      (0275) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
7B7C: 62 11 00 MOV   REG[0x11],0x0      (0276) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
7B7F: 70 EF    AND   F,0xEF             
                                        (0277) 	M8C_SetBank0
7B81: 62 13 00 MOV   REG[0x13],0x0      (0278) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
7B84: 62 12 00 MOV   REG[0x12],0x0      (0279) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
7B87: 71 10    OR    F,0x10             
                                        (0280) 	M8C_SetBank1
7B89: 62 12 00 MOV   REG[0x12],0x0      (0281) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
7B8C: 62 13 00 MOV   REG[0x13],0x0      (0282) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
7B8F: 70 EF    AND   F,0xEF             
                                        (0283) 	M8C_SetBank0
7B91: 62 11 00 MOV   REG[0x11],0x0      (0284) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
7B94: 71 10    OR    F,0x10             
                                        (0285) 	M8C_SetBank1
7B96: 62 14 00 MOV   REG[0x14],0x0      (0286) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
7B99: 62 15 00 MOV   REG[0x15],0x0      (0287) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
7B9C: 70 EF    AND   F,0xEF             
                                        (0288) 	M8C_SetBank0
7B9E: 62 17 00 MOV   REG[0x17],0x0      (0289) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
7BA1: 62 16 00 MOV   REG[0x16],0x0      (0290) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
7BA4: 71 10    OR    F,0x10             
                                        (0291) 	M8C_SetBank1
7BA6: 62 16 00 MOV   REG[0x16],0x0      (0292) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
7BA9: 62 17 00 MOV   REG[0x17],0x0      (0293) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
7BAC: 70 EF    AND   F,0xEF             
                                        (0294) 	M8C_SetBank0
7BAE: 62 15 00 MOV   REG[0x15],0x0      (0295) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
7BB1: 71 10    OR    F,0x10             
                                        (0296) 	M8C_SetBank1
7BB3: 62 18 00 MOV   REG[0x18],0x0      (0297) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
7BB6: 62 19 00 MOV   REG[0x19],0x0      (0298) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
7BB9: 70 EF    AND   F,0xEF             
                                        (0299) 	M8C_SetBank0
7BBB: 62 1B 00 MOV   REG[0x1B],0x0      (0300) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
7BBE: 62 1A 00 MOV   REG[0x1A],0x0      (0301) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
7BC1: 71 10    OR    F,0x10             
                                        (0302) 	M8C_SetBank1
7BC3: 62 1A 00 MOV   REG[0x1A],0x0      (0303) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
7BC6: 62 1B 00 MOV   REG[0x1B],0x0      (0304) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
7BC9: 70 EF    AND   F,0xEF             
                                        (0305) 	M8C_SetBank0
7BCB: 62 19 00 MOV   REG[0x19],0x0      (0306) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
7BCE: 71 10    OR    F,0x10             
                                        (0307) 	M8C_SetBank1
7BD0: 62 1C 00 MOV   REG[0x1C],0x0      (0308) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
7BD3: 62 1D 00 MOV   REG[0x1D],0x0      (0309) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
7BD6: 70 EF    AND   F,0xEF             
                                        (0310) 	M8C_SetBank0
7BD8: 62 1F 00 MOV   REG[0x1F],0x0      (0311) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
7BDB: 62 1E 00 MOV   REG[0x1E],0x0      (0312) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
7BDE: 71 10    OR    F,0x10             
                                        (0313) 	M8C_SetBank1
7BE0: 62 1E 00 MOV   REG[0x1E],0x0      (0314) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
7BE3: 62 1F 00 MOV   REG[0x1F],0x0      (0315) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
7BE6: 70 EF    AND   F,0xEF             
                                        (0316) 	M8C_SetBank0
7BE8: 62 1D 00 MOV   REG[0x1D],0x0      (0317) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
7BEB: 7F       RET                      (0318) 	ret
                                        (0319) LoadConfigTBL_bootloader_cy8c29_Bank0:
                                        (0320) ;  Global Register values
                                        (0321) 	db		60h, 28h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0322) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0323) 	db		63h, 05h		; AnalogReferenceControl register (ARF_CR)
                                        (0324) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0325) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                        (0326) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                        (0327) 	db		d6h, 00h		; I2CConfig register (I2CCFG)
                                        (0328) 	db		b0h, 10h		; Row_0_InputMux register (RDI0RI)
                                        (0329) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0330) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0331) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0332) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0333) 	db		b5h, 02h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0334) 	db		b6h, 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0335) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
                                        (0336) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
                                        (0337) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
                                        (0338) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
                                        (0339) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
                                        (0340) 	db		bdh, 00h		; Row_1_OutputDrive_0 register (RDI1SRO0)
                                        (0341) 	db		beh, 00h		; Row_1_OutputDrive_1 register (RDI1SRO1)
                                        (0342) 	db		c0h, 00h		; Row_2_InputMux register (RDI2RI)
                                        (0343) 	db		c1h, 00h		; Row_2_InputSync register (RDI2SYN)
                                        (0344) 	db		c2h, 20h		; Row_2_LogicInputAMux register (RDI2IS)
                                        (0345) 	db		c3h, 33h		; Row_2_LogicSelect_0 register (RDI2LT0)
                                        (0346) 	db		c4h, 33h		; Row_2_LogicSelect_1 register (RDI3LT1)
                                        (0347) 	db		c5h, 00h		; Row_2_OutputDrive_0 register (RDI2SRO0)
                                        (0348) 	db		c6h, 00h		; Row_2_OutputDrive_1 register (RDI2SRO1)
                                        (0349) 	db		c8h, 55h		; Row_3_InputMux register (RDI3RI)
                                        (0350) 	db		c9h, 00h		; Row_3_InputSync register (RDI3SYN)
                                        (0351) 	db		cah, 30h		; Row_3_LogicInputAMux register (RDI3IS)
                                        (0352) 	db		cbh, 33h		; Row_3_LogicSelect_0 register (RDI3LT0)
                                        (0353) 	db		cch, 33h		; Row_3_LogicSelect_1 register (RDI3LT1)
                                        (0354) 	db		cdh, 00h		; Row_3_OutputDrive_0 register (RDI3SRO0)
                                        (0355) 	db		ceh, 00h		; Row_3_OutputDrive_1 register (RDI3SRO1)
                                        (0356) 	db		6ch, 00h		; TMP_DR0 register (TMP_DR0)
                                        (0357) 	db		6dh, 00h		; TMP_DR1 register (TMP_DR1)
                                        (0358) 	db		6eh, 00h		; TMP_DR2 register (TMP_DR2)
                                        (0359) 	db		6fh, 00h		; TMP_DR3 register (TMP_DR3)
                                        (0360) ;  Instance name Boot_Counter, User Module Counter16
                                        (0361) ;       Instance name Boot_Counter, Block Name CNTR16_LSB(DBB00)
                                        (0362) 	db		23h, 00h		;Boot_Counter_CONTROL_LSB_REG(DBB00CR0)
                                        (0363) 	db		21h, 00h		;Boot_Counter_PERIOD_LSB_REG(DBB00DR1)
                                        (0364) 	db		22h, 00h		;Boot_Counter_COMPARE_LSB_REG(DBB00DR2)
                                        (0365) ;       Instance name Boot_Counter, Block Name CNTR16_MSB(DBB01)
                                        (0366) 	db		27h, 00h		;Boot_Counter_CONTROL_MSB_REG(DBB01CR0)
                                        (0367) 	db		25h, 80h		;Boot_Counter_PERIOD_MSB_REG(DBB01DR1)
                                        (0368) 	db		26h, 40h		;Boot_Counter_COMPARE_MSB_REG(DBB01DR2)
                                        (0369) ;  Instance name Boot_RxD, User Module RX8
                                        (0370) ;       Instance name Boot_RxD, Block Name RX8(DCB03)
                                        (0371) 	db		2fh, 00h		;Boot_RxD_CONTROL_REG  (DCB03CR0)
                                        (0372) 	db		2dh, 00h		;Boot_RxD_(DCB03DR1)
                                        (0373) 	db		2eh, 00h		;Boot_RxD_RX_BUFFER_REG(DCB03DR2)
                                        (0374) ;  Instance name Boot_TxD, User Module TX8
                                        (0375) ;       Instance name Boot_TxD, Block Name TX8(DCB02)
                                        (0376) 	db		2bh, 00h		;Boot_TxD_CONTROL_REG  (DCB02CR0)
                                        (0377) 	db		29h, 00h		;Boot_TxD_TX_BUFFER_REG(DCB02DR1)
                                        (0378) 	db		2ah, 00h		;Boot_TxD_(DCB02DR2)
                                        (0379) 	db		ffh
                                        (0380) LoadConfigTBL_bootloader_cy8c29_Bank1:
                                        (0381) ;  Global Register values
                                        (0382) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0383) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0384) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0385) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0386) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0387) 	db		68h, 33h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0388) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0389) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0390) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0391) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0392) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0393) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0394) 	db		e1h, 00h		; OscillatorControl_1 register (OSC_CR1)
                                        (0395) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0396) 	db		dfh, 19h		; OscillatorControl_3 register (OSC_CR3)
                                        (0397) 	db		deh, 00h		; OscillatorControl_4 register (OSC_CR4)
                                        (0398) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0399) 	db		e7h, 00h		; Type2Decimator_Control register (DEC_CR2)
                                        (0400) ;  Instance name Boot_Counter, User Module Counter16
                                        (0401) ;       Instance name Boot_Counter, Block Name CNTR16_LSB(DBB00)
                                        (0402) 	db		20h, 11h		;Boot_Counter_FUNC_LSB_REG(DBB00FN)
                                        (0403) 	db		21h, 17h		;Boot_Counter_INPUT_LSB_REG(DBB00IN)
                                        (0404) 	db		22h, 40h		;Boot_Counter_OUTPUT_LSB_REG(DBB00OU)
                                        (0405) ;       Instance name Boot_Counter, Block Name CNTR16_MSB(DBB01)
                                        (0406) 	db		24h, 31h		;Boot_Counter_FUNC_MSB_REG(DBB01FN)
                                        (0407) 	db		25h, 37h		;Boot_Counter_INPUT_MSB_REG(DBB01IN)
                                        (0408) 	db		26h, 40h		;Boot_Counter_OUTPUT_MSB_REG(DBB01OU)
                                        (0409) ;  Instance name Boot_RxD, User Module RX8
                                        (0410) ;       Instance name Boot_RxD, Block Name RX8(DCB03)
                                        (0411) 	db		2ch, 05h		;Boot_RxD_FUNC_REG     (DCB03FN)
                                        (0412) 	db		2dh, e1h		;Boot_RxD_INPUT_REG    (DCB03IN)
                                        (0413) 	db		2eh, 40h		;Boot_RxD_OUTPUT_REG   (DCB03OU)
                                        (0414) ;  Instance name Boot_TxD, User Module TX8
                                        (0415) ;       Instance name Boot_TxD, Block Name TX8(DCB02)
                                        (0416) 	db		28h, 1dh		;Boot_TxD_FUNC_REG     (DCB02FN)
                                        (0417) 	db		29h, 01h		;Boot_TxD_INPUT_REG    (DCB02IN)
                                        (0418) 	db		2ah, 44h		;Boot_TxD_OUTPUT_REG   (DCB02OU)
                                        (0419) 	db		ffh
                                        (0420) 
                                        (0421) 
                                        (0422) ; PSoC Configuration file trailer PsocConfig.asm
                                        (0423) 
                                        (0424) 
                                        (0425) 
                                        (0426) 
                                        (0427) 
                                        (0428) 
                                        (0429) 
                                        (0430) 
                                        (0431) ;-----------------------------------------------
                                        (0432) ;  EQUATES
                                        (0433) ;-----------------------------------------------
                                        (0434) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                        (0435) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                        (0436) INPUT_REG_NULL:                equ 0x00    ; Clear the input register		
                                        (0437) 
                                        (0438) .SECTION
                                        (0439) ;-----------------------------------------------------------------------------
                                        (0440) ;  FUNCTION NAME: Boot_RxD_Start(BYTE bParity)
                                        (0441) ;
                                        (0442) ;  DESCRIPTION:
                                        (0443) ;    Sets the start bit and parity in the Control register of this user module.
                                        (0444) ;
                                        (0445) ;-----------------------------------------------------------------------------
                                        (0446) ;
                                        (0447) ;  ARGUMENTS:
                                        (0448) ;    BYTE bParity - parity of received data.  Use defined masks.
                                        (0449) ;    passed in A register.
                                        (0450) ;
                                        (0451) ;  RETURNS: none
                                        (0452) ;
                                        (0453) ;  SIDE EFFECTS:
                                        (0454) ;    The A and X registers may be modified by this or future implementations
                                        (0455) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0456) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0457) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0458) ;    functions.
                                        (0459) ;
                                        (0460)  Boot_RxD_Start:
                                        (0461) _Boot_RxD_Start:
                                        (0462)    RAM_PROLOGUE RAM_USE_CLASS_1
7C90: 29 01    OR    A,0x1              (0463)    or    A, bfCONTROL_REG_START_BIT
7C92: 60 2F    MOV   REG[0x2F],A        (0464)    mov   REG[Boot_RxD_CONTROL_REG], A
                                        (0465)    RAM_EPILOGUE RAM_USE_CLASS_1
7C94: 7F       RET                      (0466)    ret
7C95: 41 23 FE AND   REG[0x23],0xFE     
                                        (0467) .ENDSECTION
                                        (0468) 
                                        (0469) .SECTION
                                        (0470) ;-----------------------------------------------------------------------------
                                        (0471) ;  FUNCTION NAME: Boot_Counter_Stop
                                        (0472) ;
                                        (0473) ;  DESCRIPTION:
                                        (0474) ;     Disables counter operation by clearing the start bit in the Control
                                        (0475) ;     register of the LSB block.
                                        (0476) ;-----------------------------------------------------------------------------
                                        (0477) ;
                                        (0478) ;  ARGUMENTS:    None
                                        (0479) ;  RETURNS:      Nothing
                                        (0480) ;  SIDE EFFECTS: 
                                        (0481) ;    The A and X registers may be modified by this or future implementations
                                        (0482) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0483) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0484) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0485) ;    functions.
                                        (0486) ;
                                        (0487)  Boot_Counter_Stop:
                                        (0488) _Boot_Counter_Stop:
                                        (0489)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0490)    Boot_Counter_Stop_M
                                        (0491)    RAM_EPILOGUE RAM_USE_CLASS_1
7C98: 7F       RET                      (0492)    ret
                                        (0493) 
                                        (0494) 
                                        (0495) .ENDSECTION
                                        (0496) 
                                        (0497) 
                                        (0498) .SECTION
                                        (0499) ;-----------------------------------------------------------------------------
                                        (0500) ;  FUNCTION NAME: Boot_RxD_bReadRxData
                                        (0501) ;
                                        (0502) ;  DESCRIPTION:
                                        (0503) ;     Reads the RX buffer register.  Should check the status regiser to make
                                        (0504) ;     sure data is valid.
                                        (0505) ;
                                        (0506) ;-----------------------------------------------------------------------------
                                        (0507) ;
                                        (0508) ;  ARGUMENTS:  none
                                        (0509) ;
                                        (0510) ;  RETURNS:
                                        (0511) ;    bRxData - returned in A.
                                        (0512) ;
                                        (0513) ;  SIDE EFFECTS:
                                        (0514) ;    The A and X registers may be modified by this or future implementations
                                        (0515) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0516) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0517) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0518) ;    functions.
                                        (0519) ;
                                        (0520)  Boot_RxD_bReadRxData:
                                        (0521) _Boot_RxD_bReadRxData:
                                        (0522)  bBoot_RxD_ReadRxData:
                                        (0523) _bBoot_RxD_ReadRxData:
                                        (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
7C99: 5D 2E    MOV   A,REG[0x2E]        (0525)    mov A, REG[Boot_RxD_RX_BUFFER_REG]
                                        (0526)    RAM_EPILOGUE RAM_USE_CLASS_1
7C9B: 7F       RET                      (0527)    ret
                                        (0528) .ENDSECTION
                                        (0529) 
                                        (0530) .SECTION
                                        (0531) ;-----------------------------------------------------------------------------
                                        (0532) ;  FUNCTION NAME: Boot_RxD_bReadRxStatus
                                        (0533) ;
                                        (0534) ;  DESCRIPTION:
                                        (0535) ;    Reads the RX Status bits in the Control/Status register.
                                        (0536) ;
                                        (0537) ;-----------------------------------------------------------------------------
                                        (0538) ;
                                        (0539) ;  ARGUMENTS:  none
                                        (0540) ;
                                        (0541) ;  RETURNS:
                                        (0542) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                        (0543) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                        (0544) ;
                                        (0545) ;  SIDE EFFECTS:
                                        (0546) ;    The A and X registers may be modified by this or future implementations
                                        (0547) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0548) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0549) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0550) ;    functions.
                                        (0551) ;
                                        (0552)  Boot_RxD_bReadRxStatus:
                                        (0553) _Boot_RxD_bReadRxStatus:
                                        (0554)  bBoot_RxD_ReadRxStatus:
                                        (0555) _bBoot_RxD_ReadRxStatus:
                                        (0556)    RAM_PROLOGUE RAM_USE_CLASS_1
7C9C: 5D 2F    MOV   A,REG[0x2F]        (0557)    mov A,  REG[Boot_RxD_CONTROL_REG]
                                        (0558)    RAM_EPILOGUE RAM_USE_CLASS_1
7C9E: 7F       RET                      (0559)    ret
                                        (0560) .ENDSECTION
                                        (0561) 
                                        (0562) .SECTION
                                        (0563) ;-----------------------------------------------------------------------------
                                        (0564) ;  FUNCTION NAME: Boot_TxD_Start(BYTE bParity)
                                        (0565) ;
                                        (0566) ;  DESCRIPTION:
                                        (0567) ;     Sets the start bit and parity in the Control register of this user module.
                                        (0568) ;     The transmitter will begin transmitting if a byte has been written into the
                                        (0569) ;     transmit buffer.
                                        (0570) ;
                                        (0571) ;-----------------------------------------------------------------------------
                                        (0572) ;
                                        (0573) ;  ARGUMENTS:
                                        (0574) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                        (0575) ;
                                        (0576) ;  RETURNS:  none
                                        (0577) ;
                                        (0578) ;  SIDE EFFECTS:
                                        (0579) ;    The A and X registers may be modified by this or future implementations
                                        (0580) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0581) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0582) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0583) ;    functions.
                                        (0584) ;
                                        (0585)  Boot_TxD_Start:
                                        (0586) _Boot_TxD_Start:
                                        (0587)    RAM_PROLOGUE RAM_USE_CLASS_1
7C9F: 29 01    OR    A,0x1              (0588)    or    A, bfCONTROL_REG_START_BIT
7CA1: 60 2B    MOV   REG[0x2B],A        (0589)    mov   REG[Boot_TxD_CONTROL_REG], A
                                        (0590)    RAM_EPILOGUE RAM_USE_CLASS_1
7CA3: 7F       RET                      (0591)    ret
                                        (0592) .ENDSECTION
                                        (0593) 
                                        (0594) .SECTION
                                        (0595) ;-----------------------------------------------------------------------------
                                        (0596) ;  FUNCTION NAME: Boot_TxD_SendData
                                        (0597) ;
                                        (0598) ;  DESCRIPTION:
                                        (0599) ;     Sends one byte through serial port.
                                        (0600) ;
                                        (0601) ;-----------------------------------------------------------------------------
                                        (0602) ;
                                        (0603) ;  ARGUMENTS:
                                        (0604) ;     BYTE  TxData - data to transmit.
                                        (0605) ;
                                        (0606) ;  RETURNS:
                                        (0607) ;
                                        (0608) ;  SIDE EFFECTS:
                                        (0609) ;    The A and X registers may be modified by this or future implementations
                                        (0610) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0611) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0612) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0613) ;    functions.
                                        (0614) ;
                                        (0615)  Boot_TxD_SendData:
                                        (0616) _Boot_TxD_SendData:
                                        (0617)    RAM_PROLOGUE RAM_USE_CLASS_1
7CA4: 60 29    MOV   REG[0x29],A        (0618)    mov REG[Boot_TxD_TX_BUFFER_REG], A
                                        (0619)    RAM_EPILOGUE RAM_USE_CLASS_1
7CA6: 7F       RET                      (0620)    ret
                                        (0621) .ENDSECTION
                                        (0622) 
                                        (0623) .SECTION
                                        (0624) ;-----------------------------------------------------------------------------
                                        (0625) ;  FUNCTION NAME: Boot_TxD_bReadTxStatus
                                        (0626) ;
                                        (0627) ;  DESCRIPTION:
                                        (0628) ;     Reads the Tx Status bits in the Control/Status register.
                                        (0629) ;
                                        (0630) ;-----------------------------------------------------------------------------
                                        (0631) ;
                                        (0632) ;  ARGUMENTS:
                                        (0633) ;
                                        (0634) ;  RETURNS:
                                        (0635) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                        (0636) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                        (0637) ;
                                        (0638) ;  SIDE EFFECTS:
                                        (0639) ;    The A and X registers may be modified by this or future implementations
                                        (0640) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0641) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0642) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0643) ;    functions.
                                        (0644) ;
                                        (0645)  Boot_TxD_bReadTxStatus:
                                        (0646) _Boot_TxD_bReadTxStatus:
                                        (0647)  bBoot_TxD_ReadTxStatus:
                                        (0648) _bBoot_TxD_ReadTxStatus:
                                        (0649)    RAM_PROLOGUE RAM_USE_CLASS_1
7CA7: 5D 2B    MOV   A,REG[0x2B]        (0650)    mov A,  REG[Boot_TxD_CONTROL_REG]
                                        (0651)    RAM_EPILOGUE RAM_USE_CLASS_1
7CA9: 7F       RET                      (0652)    ret
7CAA: 41 E1 FD AND   REG[0xE1],0xFD     
                                        (0653) 
                                        (0654) .ENDSECTION
                                        (0655) 
                                        (0656) 
                                        (0657) 
                                        (0658) 
                                        (0659) 
                                        (0660) 
                                        (0661) 
                                        (0662) 
                                        (0663) 
                                        (0664) 
                                        (0665) 
                                        (0666) .SECTION
                                        (0667) ;-----------------------------------------------------------------------------
                                        (0668) ;  FUNCTION NAME: Boot_Counter_DisableInt
                                        (0669) ;
                                        (0670) ;  DESCRIPTION:
                                        (0671) ;     Disables this counter's interrupt by clearing the interrupt enable
                                        (0672) ;     mask bit associated with this User Module.
                                        (0673) ;-----------------------------------------------------------------------------
                                        (0674) ;
                                        (0675) ;  ARGUMENTS:    None
                                        (0676) ;  RETURNS:      Nothing
                                        (0677) ;  SIDE EFFECTS: 
                                        (0678) ;    The A and X registers may be modified by this or future implementations
                                        (0679) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0680) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0681) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0682) ;    functions.
                                        (0683) ;
                                        (0684)  Boot_Counter_DisableInt:
                                        (0685) _Boot_Counter_DisableInt:
                                        (0686)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0687)    Boot_Counter_DisableInt_M
                                        (0688)    RAM_EPILOGUE RAM_USE_CLASS_1
7CAD: 7F       RET                      (0689)    ret
7CAE: 43 23 01 OR    REG[0x23],0x1      
                                        (0690) 
                                        (0691) 
                                        (0692) .ENDSECTION
                                        (0693) 
                                        (0694) .SECTION
                                        (0695) ;-----------------------------------------------------------------------------
                                        (0696) ;  FUNCTION NAME: Boot_Counter_Start
                                        (0697) ;
                                        (0698) ;  DESCRIPTION:
                                        (0699) ;     Sets the start bit in the Control register of this user module.  The
                                        (0700) ;     counter will begin counting on the next input clock as soon as the
                                        (0701) ;     enable input is asserted high.
                                        (0702) ;-----------------------------------------------------------------------------
                                        (0703) ;
                                        (0704) ;  ARGUMENTS:    None
                                        (0705) ;  RETURNS:      Nothing
                                        (0706) ;  SIDE EFFECTS: 
                                        (0707) ;    The A and X registers may be modified by this or future implementations
                                        (0708) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0709) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0710) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0711) ;    functions.
                                        (0712) ;
                                        (0713)  Boot_Counter_Start:
                                        (0714) _Boot_Counter_Start:
                                        (0715)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0716)    Boot_Counter_Start_M
                                        (0717)    RAM_EPILOGUE RAM_USE_CLASS_1
7CB1: 7F       RET                      (0718)    ret
                                        (0719) 
                                        (0720) 
                                        (0721) .ENDSECTION
                                        (0722) 
                                        (0723) .SECTION
                                        (0724) ;-----------------------------------------------------------------------------
                                        (0725) ;  FUNCTION NAME: Boot_Counter_WritePeriod
                                        (0726) ;
                                        (0727) ;  DESCRIPTION:
                                        (0728) ;     Write the 16-bit period value into the Period register (DR1).
                                        (0729) ;-----------------------------------------------------------------------------
                                        (0730) ;
                                        (0731) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                        (0732) ;  RETURNS:   Nothing
                                        (0733) ;  SIDE EFFECTS:
                                        (0734) ;    If the counter user module is stopped, then this value will also be
                                        (0735) ;    latched into the Count registers (DR0).
                                        (0736) ;     
                                        (0737) ;    The A and X registers may be modified by this or future implementations
                                        (0738) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0739) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0740) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0741) ;    functions.
                                        (0742) ;
                                        (0743)  Boot_Counter_WritePeriod:
                                        (0744) _Boot_Counter_WritePeriod:
                                        (0745)    RAM_PROLOGUE RAM_USE_CLASS_1
7CB2: 60 21    MOV   REG[0x21],A        (0746)    mov   reg[Boot_Counter_PERIOD_LSB_REG], A
7CB4: 5B       MOV   A,X                (0747)    mov   A, X
7CB5: 60 25    MOV   REG[0x25],A        (0748)    mov   reg[Boot_Counter_PERIOD_MSB_REG], A
                                        (0749)    RAM_EPILOGUE RAM_USE_CLASS_1
7CB7: 7F       RET                      (0750)    ret
                                        (0751) 
                                        (0752) 
                                        (0753) .ENDSECTION
                                        (0754) 
                                        (0755) .SECTION
                                        (0756) ;-----------------------------------------------------------------------------
                                        (0757) ;  FUNCTION NAME: Boot_Counter_WriteCompareValue
                                        (0758) ;
                                        (0759) ;  DESCRIPTION:
                                        (0760) ;     Writes compare value into the Compare register (DR2).
                                        (0761) ;-----------------------------------------------------------------------------
                                        (0762) ;
                                        (0763) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
                                        (0764) ;  RETURNS:      Nothing
                                        (0765) ;  SIDE EFFECTS: 
                                        (0766) ;    The A and X registers may be modified by this or future implementations
                                        (0767) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0768) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0769) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0770) ;    functions.
                                        (0771) ;
                                        (0772)  Boot_Counter_WriteCompareValue:
                                        (0773) _Boot_Counter_WriteCompareValue:
                                        (0774)    RAM_PROLOGUE RAM_USE_CLASS_1
7CB8: 60 22    MOV   REG[0x22],A        (0775)    mov   reg[Boot_Counter_COMPARE_LSB_REG], A
7CBA: 5B       MOV   A,X                (0776)    mov   A, X
7CBB: 60 26    MOV   REG[0x26],A        (0777)    mov   reg[Boot_Counter_COMPARE_MSB_REG], A
                                        (0778)    RAM_EPILOGUE RAM_USE_CLASS_1
7CBD: 7F       RET                      (0779)    ret
                                        (0780) 
                                        (0781) 
                                        (0782) .ENDSECTION
                                        (0783) 
                                        (0784) .SECTION
                                        (0785) ;-----------------------------------------------------------------------------
                                        (0786) ;  FUNCTION NAME: Boot_Counter_wReadCounter
                                        (0787) ;
                                        (0788) ;  DESCRIPTION:
                                        (0789) ;     Returns the value in the Count register (DR0), preserving the value in
                                        (0790) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                        (0791) ;     from the Count to the Compare registers by holding the clock low in
                                        (0792) ;     the MSB PSoC block.
                                        (0793) ;-----------------------------------------------------------------------------
                                        (0794) ;
                                        (0795) ;  ARGUMENTS: None
                                        (0796) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                        (0797) ;  SIDE EFFECTS:
                                        (0798) ;     1) The user module is stopped momentarily and one or more counts may be missed.
                                        (0799) ;     2) The A and X registers may be modified by this or future implementations
                                        (0800) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0801) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0802) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0803) ;        functions.
                                        (0804) ;
                                        (0805)  Boot_Counter_wReadCounter:
                                        (0806) _Boot_Counter_wReadCounter:
                                        (0807)  wBoot_Counter_ReadCounter:                      ; this name deprecated
                                        (0808) _wBoot_Counter_ReadCounter:                      ; this name deprecated
                                        (0809) 
                                        (0810)    bOrigCompareValue:      EQU   0                  ; Frame offset to temp Compare store
                                        (0811)    bOrigControlReg:        EQU   2                  ; Frame offset to temp CR0     store
                                        (0812)    bOrigClockSetting:      EQU   3                  ; Frame offset to temp Input   store
                                        (0813)    wCounter:               EQU   4                  ; Frame offset to temp Count   store
                                        (0814)    STACK_FRAME_SIZE:       EQU   6                  ; max stack frame size is 6 bytes
                                        (0815) 
                                        (0816)    RAM_PROLOGUE RAM_USE_CLASS_2
7CBE: 4F       MOV   X,SP               (0817)    mov   X, SP                                      ; X <-  stack frame pointer
7CBF: 5D 26    MOV   A,REG[0x26]        (0818)    mov   A, reg[Boot_Counter_COMPARE_MSB_REG]    ; Save the Compare register on the stack
7CC1: 08       PUSH  A                  (0819)    push  A                                          ;
7CC2: 5D 22    MOV   A,REG[0x22]        (0820)    mov   A, reg[Boot_Counter_COMPARE_LSB_REG]    ;
7CC4: 08       PUSH  A                  (0821)    push  A                                          ;   -stack frame now 2 bytes-
7CC5: 5D 23    MOV   A,REG[0x23]        (0822)    mov   A, reg[Boot_Counter_CONTROL_LSB_REG]    ; Save CR0 (running or stopped state)
7CC7: 08       PUSH  A                  (0823)    push  A                                          ;   -stack frame now 3 bytes-
7CC8: 41 23 FE AND   REG[0x23],0xFE     
7CCB: 71 10    OR    F,0x10             
                                        (0824)    Boot_Counter_Stop_M                           ; Disable (stop) the Counter if running
                                        (0825)    M8C_SetBank1                                     ;
7CCD: 5D 21    MOV   A,REG[0x21]        (0826)    mov   A, reg[Boot_Counter_INPUT_LSB_REG]      ; save the LSB clock input setting
7CCF: 08       PUSH  A                  (0827)    push  A                                          ;   on the stack (now 4 bytes) and ...
                                        (0828)                                                     ;   hold the clock low:
7CD0: 62 21 00 MOV   REG[0x21],0x0      (0829)    mov   reg[Boot_Counter_INPUT_LSB_REG], INPUT_REG_NULL
7CD3: 70 EF    AND   F,0xEF             
                                        (0830)    M8C_SetBank0                                     ; Extract the Count via DR2 register
7CD5: 5D 24    MOV   A,REG[0x24]        (0831)    mov   A, reg[Boot_Counter_COUNTER_MSB_REG]    ; DR2 <- DR0 (in the MSB block)
7CD7: 5D 26    MOV   A,REG[0x26]        (0832)    mov   A, reg[Boot_Counter_COMPARE_MSB_REG]    ; Stash the Count MSB on the stack
7CD9: 08       PUSH  A                  (0833)    push  A                                          ;   -stack frame is now 5 bytes
7CDA: 5D 20    MOV   A,REG[0x20]        (0834)    mov   A, reg[Boot_Counter_COUNTER_LSB_REG]    ; DR2 <- DR0 (in the LSB block)
7CDC: 5D 22    MOV   A,REG[0x22]        (0835)    mov   A, reg[Boot_Counter_COMPARE_LSB_REG]    ; Stash the Count LSB on the stack
7CDE: 08       PUSH  A                  (0836)    push  A                                          ;   -stack frame is now 6 bytes-
7CDF: 52 00    MOV   A,[X+0]            (0837)    mov   A, [X+bOrigCompareValue]                   ; Restore the Compare MSB register
7CE1: 60 26    MOV   REG[0x26],A        (0838)    mov   reg[Boot_Counter_COMPARE_MSB_REG], A    ;
7CE3: 52 01    MOV   A,[X+1]            (0839)    mov   A, [X+bOrigCompareValue+1]                 ; Restore the Compare LSB register
7CE5: 60 22    MOV   REG[0x22],A        (0840)    mov   reg[Boot_Counter_COMPARE_LSB_REG], A    ;
7CE7: 71 10    OR    F,0x10             
                                        (0841)    M8C_SetBank1                                     ; ---Restore the counter operation
7CE9: 52 03    MOV   A,[X+3]            (0842)    mov   A, [X+bOrigClockSetting]                   ; Grab the LSB clock setting...
7CEB: 60 21    MOV   REG[0x21],A        (0843)    mov   reg[Boot_Counter_INPUT_LSB_REG], A      ;   and restore it
7CED: 70 EF    AND   F,0xEF             
                                        (0844)    M8C_SetBank0                                     ; Now re-enable (start) the counter
7CEF: 52 02    MOV   A,[X+2]            (0845)    mov   A, [X+bOrigControlReg]                     ;   if it was running when
7CF1: 60 23    MOV   REG[0x23],A        (0846)    mov   reg[Boot_Counter_CONTROL_LSB_REG], A    ;   this function was first called
7CF3: 18       POP   A                  (0847)    pop   A                                          ; Setup the return value
7CF4: 20       POP   X                  (0848)    pop   X                                          ;
7CF5: 38 FC    ADD   SP,0xFC            (0849)    ADD   SP, -(STACK_FRAME_SIZE-2)                  ; Zap remainder of stack frame
7CF7: 70 3F    AND   F,0x3F             
7CF9: 71 C0    OR    F,0xC0             
                                        (0850)    RAM_EPILOGUE RAM_USE_CLASS_2
7CFB: 7F       RET                      (0851)    ret
                                        (0852) 
                                        (0853) .ENDSECTIONFILE: .\flashapi.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:  FlashBlock.asm
                                        (0004) ;;   Version: 2.20, Updated on 2011/6/28 at 6:8:5
                                        (0005) ;;  Generated by PSoC Designer 5.1.2306
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Routines in this file perform Flash Block Write and Read operations - CY8C29xxx and CY8C24x90
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) export    bFlashWriteBlock
                                        (0023) export   _bFlashWriteBlock
                                        (0024) export    FlashReadBlock
                                        (0025) export   _FlashReadBlock
                                        (0026) export   FlashCheckSum
                                        (0027) export   _FlashCheckSum
                                        (0028) export   Boot_Is_Program_Good
                                        (0029) export   _Boot_Is_Program_Good
                                        (0030) 
                                        (0031) include "m8c.inc"
                                        (0032) include "m8ssc.inc"
                                        (0033) include "flashblock.inc"
                                        (0034) include "memory.inc"		;File generated by PSoC Designer (Project dependent)
                                        (0035) 
                                        (0036) 
                                        (0037) ;--------------------------------------------
                                        (0038) ;  Declare Flash RAM storage at top of RAM
                                        (0039) ;     This data area is reserved for exclusive
                                        (0040) ;     use by Supervisory operations.
                                        (0041) ;--------------------------------------------
                                        (0042)    area SSCParmBlk(RAM,ABS)
                                        (0043)    ORG F8H
                                        (0044) 
                                        (0045) SSCParameterBlk:                   blk      8     ; reserve 8 bytes: F8 - FF for supervisory operation
                                        (0046) 
                                        (0047) ;--------------------------------
                                        (0048) ; SSC_Action macro command codes
                                        (0049) ;--------------------------------
                                        (0050) FLASH_OPER_KEY:                     equ      3Ah   ; flash operation key
                                        (0051) FLASH_WRITE:                        equ      2     ; flash write operation supervisory command
                                        (0052) FLASH_ERASE:                        equ      3     ; flash erase operation supervisory command
                                        (0053) FLASH_TEMP_TABLE_LOOKUP:            equ      6     ; flash temperature table command
                                        (0054) 
                                        (0055) ;-------------------------------------
                                        (0056) ; Flash temperature programming table
                                        (0057) ;-------------------------------------
                                        (0058) TEMPERATURE_TABLE_ID:               equ      3     ; flash temperature programming table ID
                                        (0059) 
                                        (0060) ;--------------------------------------------------------------
                                        (0061) ; Supervisory Operation Templates:
                                        (0062) ;     Each system supervisory call uses the reserved data area
                                        (0063) ;     a little different.  Create overlay templates to improve
                                        (0064) ;     readability and maintenance.
                                        (0065) ;--------------------------------------------------------------
                                        (0066) 
                                        (0067) ;Common Supervisory Code Variables
                                        (0068)    bSSC_KEY1:                       equ      F8h   ; supervisory key
                                        (0069)    bTEMP_SPACE:                     equ      F8h   ; temporary storage when not used for KEY1
                                        (0070)    bSSC_KEYSP:                      equ      F9h   ; supervisory stack ptr key
                                        (0071)    bSSC_ResultCode:                 equ      F8h   ; result code
                                        (0072) 
                                        (0073) ;SSC Return Codes
                                        (0074)    bSSC_FAIL:                       equ      01h   ; fail return code
                                        (0075)    bSSC_SUCCESS:                    equ      00h   ; success return code
                                        (0076) 
                                        (0077) ;Flash Erase Operation Template
                                        (0078)    bSSC_FLASH_BlockId:              equ      FAh   ; blockId for Erase and Read
                                        (0079)    bSSC_FLASH_BlockID_BANK:         equ      FAh   ; block ID page register in bank 1
                                        (0080)    bSSC_FLASH_PulseWidth:           equ      FCh   ; Erase pulse width
                                        (0081) 
                                        (0082) ;Flash Write Operation Template
                                        (0083)    bSSC_WRITE_BlockId:              equ      FAh   ; block ID
                                        (0084)    bSSC_WRITE_BlockID_BANK:         equ      FAh   ; block ID page register in bank 1
                                        (0085)    pSSC_WRITE_FlashBuffer:          equ      FBh   ; pointer to data buffer
                                        (0086)    bSSC_WRITE_PulseWidth:           equ      FCh   ; flash write pulse width or ReadCount
                                        (0087)    bSSC_WRITE_State:                equ      FDh   ; reserved
                                        (0088)    bSSC_WRITE_Delay:                equ      FEh   ; flash macro sequence delay count
                                        (0089)    bSSC_WRITE_ResultCode:           equ      FFh   ; temporary result code
                                        (0090) 
                                        (0091) ;Flash Write Operation Return Code
                                        (0092)    bSSC_WRITE_FAIL:                 equ      00h   ; failure
                                        (0093)    bSSC_WRITE_SUCCESS:              equ      01h   ; pass
                                        (0094) 
                                        (0095) ;Flash Sequence Time Delay
                                        (0096)    bSSC_WRITE_DELAY:                equ      56h   ; 100us delay at 12MHz
                                        (0097) 
                                        (0098) ;Flash Read Operation Template
                                        (0099)    pSSC_READ_FlashBuffer:           equ      FBh   ; pointer to data buffer
                                        (0100)    wSSC_READ_Counter:               equ      FDh   ; byte counter
                                        (0101) 
                                        (0102) ; Table Lookup Template - NOTE that result is a table overlaying reserved area
                                        (0103)    bSSC_TABLE_TableId:              equ      FAh   ; table ID
                                        (0104) 
                                        (0105) ; Temperature Table Template - returned data after performing a
                                        (0106) ;     Table lookup of table #7 - Pulse Width Equation data based on Temperature - y= mt+b
                                        (0107) ;     Composed to two structures - 3 Bytes each - contains slope, y intercept and multiplier
                                        (0108) ;     Structure 1 is for temperatures from [-40,0]C and structure 2 is for temperaturs from [0,40]C.
                                        (0109)    sTEMP_LineEquationBelowZero:     equ      F8h   ; Line Equation data below zero - m,b,Erase->Program multiplier
                                        (0110)    sTEMP_LineEquationAboveZero:     equ      FBh   ; Line Equation data above zero - m,b,Erase->Program multiplier
                                        (0111)    bTEMP_TempTableRevision:         equ      FFh   ; Table Revision number
                                        (0112)    bTEMP_PulseWidthErase:           equ      FEh   ; Temporary storage area after table validation
                                        (0113)    bTEMP_PulseWidthProgram:         equ      FFh   ; Temporary storage area after table validation
                                        (0114)    ;offsets into each substructure
                                        (0115)    cTEMP_SlopeOffset:               equ      0     ; Slope offset in Temp table template
                                        (0116)    cTEMP_InterceptOffset:           equ      1     ; Intercept offset in Temp table template
                                        (0117)    bTEMP_ProgMultOffset:            equ      2     ; Program multiplier
                                        (0118) 
                                        (0119)    VALID_TABLE_REVISION:            equ      1     ; Temp Table revision number
                                        (0120) 
                                        (0121) 
                                        (0122) ; Flash State mode bits - these bits are used to prevent inadvertent jumping into
                                        (0123) ; the flash write API.  If the state does not match then a HALT instruction will
                                        (0124) ; be executed.
                                        (0125) 
                                        (0126)    STATE_SET_CLOCK:                 equ      01h
                                        (0127)    STATE_CALCULATE_PW:              equ      02h
                                        (0128)    STATE_ERASE_BLOCK:               equ      04h
                                        (0129)    STATE_WRITE_BLOCK:               equ      08h
                                        (0130)    STATE_RESTORE_CLOCK:             equ      10h
                                        (0131)    STATE_DONE:                      equ      20h
                                        (0132) 
                                        (0133) ;--------------------------------------------
                                        (0134) ;  Restore area to Code area
                                        (0135) ;--------------------------------------------
                                        (0136) IF	(TOOLCHAIN & HITECH)
                                        (0137) psect BootLoaderArea global
                                        (0138) ELSE
                                        (0139) Area BootLoaderArea(ROM,REL,CON)
                                        (0140) ENDIF
                                        (0141) // ----------------------------------------------------------------------------------------
                                        (0142) //	Control subroutine which determine whether user program is based on BootLoader Project
                                        (0143) //  Return: 0 - if bad program
                                        (0144) // 	  	    1 - if all right
                                        (0145) // ----------------------------------------------------------------------------------------
                                        (0146) Boot_Is_Program_Good:
                                        (0147) _Boot_Is_Program_Good:
7CFC: 10       PUSH  X                  (0148) 	push X
7CFD: 51 06    MOV   A,[__r0]           (0149) 	mov A,[__r0]
7CFF: 08       PUSH  A                  (0150) 	push A
                                        (0151) 	
7D00: 50 02    MOV   A,0x2              (0152) 	mov A,2
7D02: 57 A0    MOV   X,0xA0             (0153) 	mov X,A0h			; init start control sequence address
7D04: 53 06    MOV   [__r0],A           (0154) 	mov [__r0],A		; initiate counter
                                        (0155) Start_Control:	
7D06: 50 00    MOV   A,0x0              (0156) 	mov A,0
7D08: 28       ROMX                     (0157) 	romx
7D09: 3A 06    CMP   A,[__r0]           (0158) 	cmp A,[__r0]		; does addr 00A0 contain 0x7D (ljump)
7D0B: B0 10    JNZ   0x7D1C             (0159) 	jnz Error_Program
7D0D: 76 06    INC   [__r0]             (0160) 	inc [__r0]
7D0F: 75       INC   X                  (0161) 	inc X
7D10: 5B       MOV   A,X                (0162) 	mov A,X
7D11: 39 A6    CMP   A,0xA6             (0163) 	cmp A,A6h			; is > than last sequence address?
7D13: BF F2    JNZ   0x7D06             (0164) 	jnz Start_Control	; goto next sequence address
                                        (0165) 	
7D15: 18       POP   A                  (0166) 	pop A	
7D16: 53 06    MOV   [__r0],A           (0167) 	mov [__r0],A
7D18: 20       POP   X                  (0168) 	pop X
7D19: 50 01    MOV   A,0x1              (0169) 	mov A,1		; restore register from stack
7D1B: 7F       RET                      (0170) 	ret			; if ok then return 1
                                        (0171) Error_Program:
7D1C: 18       POP   A                  (0172) 	pop A	
7D1D: 53 06    MOV   [__r0],A           (0173) 	mov [__r0],A
7D1F: 20       POP   X                  (0174) 	pop X		; restore register from stack
7D20: 50 00    MOV   A,0x0              (0175) 	mov A,0		; if bad program then return 0
7D22: 7F       RET                      (0176) 	ret	
                                        (0177) 
                                        (0178) // ---------------------------
                                        (0179) // Flash Block CheckSum
                                        (0180) // Entrance: A - LSB of block ID
                                        (0181) //           X - MSB of block ID 
                                        (0182) // Exit: A - CheckSum
                                        (0183) FlashCheckSum:
                                        (0184) _FlashCheckSum:
                                        (0185) 
7D23: 10       PUSH  X                  (0186) 	push X
7D24: 4F       MOV   X,SP               (0187) 	mov X,SP
                                        (0188) 
7D25: 51 06    MOV   A,[__r0]           (0189) 	mov A,[__r0]
7D27: 08       PUSH  A                  (0190) 	push A
7D28: 51 05    MOV   A,[__r1]           (0191) 	mov A,[__r1]
7D2A: 08       PUSH  A                  (0192) 	push A
7D2B: 51 04    MOV   A,[__r2]           (0193) 	mov A,[__r2]
7D2D: 08       PUSH  A                  (0194) 	push A
                                        (0195) 
7D2E: 52 FB    MOV   A,[X-5]            (0196)     mov A,[X-5]						; A = MSB of BlockID
7D30: 59 FC    MOV   X,[X-4]            (0197) 	mov X,[X-4]						; X = LSB of BlockID
                                        (0198) 
                                        (0199) 					// calculate address addr = BlockID<<6 = BlockID*64
7D32: 5A 06    MOV   [__r0],X           (0200) 	mov [__r0],X
7D34: 65 06    ASL   [__r0]             (0201)     asl [__r0]
7D36: 6A       RLC   A                  (0202)     rlc A
7D37: 65 06    ASL   [__r0]             (0203)     asl [__r0]
7D39: 6A       RLC   A                  (0204)     rlc A
7D3A: 65 06    ASL   [__r0]             (0205)     asl [__r0]
7D3C: 6A       RLC   A                  (0206)     rlc A
7D3D: 65 06    ASL   [__r0]             (0207) 	asl [__r0]
7D3F: 6A       RLC   A                  (0208)     rlc A
7D40: 65 06    ASL   [__r0]             (0209)     asl [__r0]
7D42: 6A       RLC   A                  (0210)     rlc A
7D43: 65 06    ASL   [__r0]             (0211)     asl [__r0]
7D45: 6A       RLC   A                  (0212)     rlc A
7D46: 58 06    MOV   X,[__r0]           (0213)     mov X,[__r0]
                                        (0214) 	
7D48: 53 05    MOV   [__r1],A           (0215) 	mov [__r1],A		; Address MSB
7D4A: 55 06 40 MOV   [__r0],0x40        (0216) 	mov [__r0],64		; Cycle Iterator
7D4D: 55 04 00 MOV   [__r2],0x0         (0217) 	mov [__r2],0		; CheckSum
                                        (0218) calc_cs:
7D50: 7A 06    DEC   [__r0]             (0219) 	dec [__r0]			; decrement Cycle Iterator
7D52: 51 05    MOV   A,[__r1]           (0220) 	mov A,[__r1]
7D54: 28       ROMX                     (0221) 	romx
7D55: 04 04    ADD   [__r2],A           (0222) 	add [__r2],A
7D57: 75       INC   X                  (0223) 	inc X				; increment X to get next address
7D58: 2E 06 00 OR    [__r0],0x0         (0224) 	or [__r0],0			; if ([__r0]!=0) goto calc_cs;
7D5B: BF F4    JNZ   0x7D50             (0225) 	jnz calc_cs			; 
                                        (0226) 
7D5D: 51 04    MOV   A,[__r2]           (0227) 	mov A,[__r2]		; return CheckSum  
                                        (0228) 	
7D5F: 20       POP   X                  (0229) 	pop X
7D60: 5A 04    MOV   [__r2],X           (0230) 	mov [__r2],X
7D62: 20       POP   X                  (0231) 	pop X
7D63: 5A 05    MOV   [__r1],X           (0232) 	mov [__r1],X
7D65: 20       POP   X                  (0233) 	pop X
7D66: 5A 06    MOV   [__r0],X           (0234) 	mov [__r0],X
                                        (0235) 
                                        (0236) //	mov [bSSC_WRITE_BlockId],A
                                        (0237) //	SSC_Action FLASH_CHECKSUM		// CheckSum return in [KEY2][KEY1]
                                        (0238) //	mov A,[bSSC_KEY1]		
7D68: 20       POP   X                  (0239) 	pop X
7D69: 7F       RET                      (0240) 	ret
                                        (0241) ;-----------------------------------------------------------------------------
                                        (0242) ;  MACRO NAME: SSC_Action
                                        (0243) ;
                                        (0244) ;  DESCRIPTION:
                                        (0245) ;     Performs locally defined supervisory operations.
                                        (0246) ;
                                        (0247) ;     !!! DO NOT CHANGE THIS CODE !!!
                                        (0248) ;        This sequence of opcodes provides a
                                        (0249) ;        signature for the debugger and ICE.
                                        (0250) ;     !!! DO NOT CHANGE THIS CODE !!!
                                        (0251) ;
                                        (0252) ;  ARGUMENTS:
                                        (0253) ;     BYTE  bOperation   - specified supervisory operation - defined operations
                                        (0254) ;                          are:  FLASH_WRITE, FLASH_ERASE, FLASH_TEMP_TABLE_LOOKUP.
                                        (0255) ;
                                        (0256) ;  RETURNS:
                                        (0257) ;     none.
                                        (0258) ;
                                        (0259) ;  SIDE EFFECTS:
                                        (0260) ;     A and X registers are destroyed
                                        (0261) ;
                                        (0262) ;  PROCEDURE:
                                        (0263) ;     1) specify a 3 byte stack frame.  Save in [KEYSP]
                                        (0264) ;     2) insert the flash Supervisory key in [KEY1]
                                        (0265) ;     3) store flash operation function code in A
                                        (0266) ;     4) call the supervisory code
                                        (0267) ;-----------------------------------------------------------------------------
                                        (0268) macro SSC_Action
                                        (0269)       mov   X, SP                         ; copy SP into X
                                        (0270)       mov   A, X                          ; mov to A
                                        (0271)       add   A, 3                          ; create 3 byte stack frame
                                        (0272)       mov   [bSSC_KEYSP], A               ; save stack frame for supervisory code
                                        (0273)       mov   [bSSC_KEY1], FLASH_OPER_KEY   ; load the supervisory code for flash operations
                                        (0274)       mov   A, @0                         ; load A with specific Flash operation
                                        (0275)       SSC                                 ; SSC call the supervisory code
                                        (0276) endm
                                        (0277) 
                                        (0278) ;-----------------------------------------------------------------------------
                                        (0279) ;  FUNCTION NAME: bFlashWriteBlock
                                        (0280) ;
                                        (0281) ;  DESCRIPTION:
                                        (0282) ;     Writes 64 bytes of data to the flash at the specified blockId.
                                        (0283) ;
                                        (0284) ;     Regardless of the size of the buffer, this routine always writes 64
                                        (0285) ;     bytes of data. If the buffer is less than 64 bytes, then the next
                                        (0286) ;     64-N bytes of data will be written to fill the rest of flash block data.
                                        (0287) ;
                                        (0288) ;  ARGUMENTS:
                                        (0289) ;     X ->  psBlockWriteData  -  a structure that holds the
                                        (0290) ;                                calling arguments and some reserved space
                                        (0291) ;
                                        (0292) ;  RETURNS:
                                        (0293) ;     BYTE - successful if NON-Zero returned.
                                        (0294) ;
                                        (0295) ;     ASSEMBLER - returned in Accumulator.
                                        (0296) ;
                                        (0297) ;  SIDE EFFECTS:
                                        (0298) ;     1) CPU clock temporarily set to 12MHz.
                                        (0299) ;
                                        (0300) ;  PROCEDURE:
                                        (0301) ;     1) Setup the proper CPU clock - 12 MHz or 6MHz depending on state of SLIMO
                                        (0302) ;     2) Compute the pulsewidths
                                        (0303) ;     3) Erase the specified block
                                        (0304) ;     4) Program the specified block
                                        (0305) ;     5) restore the original CPU rate
                                        (0306) ;     6) check the result code and return
                                        (0307) ;-----------------------------------------------------------------------------
                                        (0308) ; Place Halt instruction code here to mitigate wondering into this code from the top
7D6A: 30       HALT                     (0309)    halt
7D6B: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0310) .SECTION
                                        (0311)  bFlashWriteBlock:
                                        (0312) _bFlashWriteBlock:
                                        (0313)    ; Preserve the SMM or LMM paging mode
                                        (0314)    RAM_SETPAGE_CUR 0          ; set paging mode
                                        (0315) 
7D6E: 53 F8    MOV   [0xF8],A           (0316)    mov   [bTEMP_SPACE], A     ; temporarily store the MSB of the WriteBlock structure
7D70: 5D F7    MOV   A,REG[0xF7]        (0317)    mov   A, reg[CPU_F]        ; grab the current CPU flag register and save on stack
7D72: 08       PUSH  A                  (0318)    push  A
7D73: 21 C0    AND   A,0xC0             (0319)    and   a, c0h
7D75: B0 07    JNZ   0x7D7D             (0320)    jnz   YesPging
                                        (0321)    ;  Enforce MSB to 0 when not in a paging mode
7D77: 56 02 00 MOV   [X+2],0x0          (0322)    mov   [X+pARG_FlashBuffer], 0
7D7A: 55 F8 00 MOV   [0xF8],0x0         (0323)    mov   [bTEMP_SPACE], 0
                                        (0324) YesPging:
7D7D: 51 F8    MOV   A,[0xF8]           (0325)    mov   A, [bTEMP_SPACE]     ; restore the MSB of the WriteBlock structure
7D7F: 70 BF    AND   F,0xBF             
7D81: 60 D3    MOV   REG[0xD3],A        
                                        (0326) 
                                        (0327)    ; Since the flash SSC operations all reference page 0, save and set the current ptr
                                        (0328)    ; to page 0 and the X_ptr to track input data page.
                                        (0329)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0330)    RAM_SETPAGE_IDX A
                                        (0331) 
                                        (0332)    ; Set the intial state variable - if code entered from the top - then state
                                        (0333)    ; variable will not catch this inadvertent entry.  However, any entry from
                                        (0334)    ; made after this statement should be caught!
7D83: 55 FD 01 MOV   [0xFD],0x1         (0335)    mov   [bSSC_WRITE_State], STATE_SET_CLOCK
                                        (0336) 
                                        (0337) ; Step 1 - setup the proper CPU clock - 12 MHz if SLIMO NOT enabled, else 6MHz
                                        (0338)    ; Check the state variable - are we supposed to be here?
7D86: 3C FD 01 CMP   [0xFD],0x1         (0339)    cmp   [bSSC_WRITE_State], STATE_SET_CLOCK
7D89: B0 C5    JNZ   0x7E4F             (0340)    jnz   bFlashWriteStateError
7D8B: 71 10    OR    F,0x10             
                                        (0341) 
                                        (0342)    ; State - Set Clock
                                        (0343)    M8C_SetBank1
7D8D: 5D E0    MOV   A,REG[0xE0]        (0344)    mov   A, reg[OSC_CR0]                  ; Get the System Oscillator control register
7D8F: 08       PUSH  A                  (0345)    push  A                                ;     and save it on the stack
7D90: 21 F8    AND   A,0xF8             (0346)    and   A, ~OSC_CR0_CPU                  ; Clear the CPU clock selects
                                        (0347) 
                                        (0348)    ; Check state of SLIMO
7D92: 49 FE 10 TST   REG[0xFE],0x10     (0349)    tst   reg[CPU_SCR1], CPU_SCR1_SLIMO
7D95: A0 05    JZ    0x7D9B             (0350)    jz    .Set12MHz                        ; if Z=0 then SLIMO NOT enabled - set 12MHz
                                        (0351) 
                                        (0352) .Set6MHz:
7D97: 29 03    OR    A,0x3              (0353)    or    A, OSC_CR0_CPU_24MHz             ; SLIMO enabled - set CPU clock to 6MHz
7D99: 80 03    JMP   0x7D9D             (0354)    jmp   .SetOSC                          ;  IMO clock max is 6MHz - DIVISOR = 1 ==> 24MHz setting
                                        (0355) .Set12MHz:
7D9B: 29 02    OR    A,0x2              (0356)    or    A, OSC_CR0_CPU_12MHz             ; Set CPU clock to 12 MHz
                                        (0357) .SetOSC:
7D9D: 60 E0    MOV   REG[0xE0],A        (0358)    mov   reg[OSC_CR0], A
7D9F: 70 EF    AND   F,0xEF             
                                        (0359)    M8C_SetBank0
                                        (0360) 
                                        (0361) ; Step 2 - compute the pulsewidths
                                        (0362) ComputePulseWidths:
7DA1: 65 FD    ASL   [0xFD]             (0363)    asl   [bSSC_WRITE_State]               ; update the state variable
                                        (0364)    ; Check the state variable - are we supposed to be here?
7DA3: 3C FD 02 CMP   [0xFD],0x2         (0365)    cmp   [bSSC_WRITE_State], STATE_CALCULATE_PW
7DA6: B0 A8    JNZ   0x7E4F             (0366)    jnz   bFlashWriteStateError
                                        (0367) 
                                        (0368)    ; State - Calculate PW
7DA8: 90 B9    CALL  0x7E63             (0369)    call  bComputePulseWidth
                                        (0370)    ; Preset the resturn code to Success
7DAA: 39 00    CMP   A,0x0              (0371)    cmp   A, bSSC_SUCCESS                  ; Check the return value
7DAC: A0 09    JZ    0x7DB6             (0372)    jz    EraseBlock                       ;     the pulse width was computed OK
                                        (0373)    ; A bad pulse width table was found!
                                        (0374)    ; Need to set the result code, restore the clock, and then exit!
7DAE: 55 FF 00 MOV   [0xFF],0x0         (0375)    mov   [bSSC_WRITE_ResultCode], bSSC_WRITE_FAIL
7DB1: 55 FD 10 MOV   [0xFD],0x10        (0376)    mov   [bSSC_WRITE_State], STATE_RESTORE_CLOCK
7DB4: 80 85    JMP   0x7E3A             (0377)    jmp   RestoreClock
                                        (0378) 
                                        (0379) ; Step 3 - Erase the specified flash block
                                        (0380) EraseBlock:
7DB6: 65 FD    ASL   [0xFD]             (0381)    asl   [bSSC_WRITE_State]               ; update the state variable
                                        (0382)    ; State - Erase Block
                                        (0383) 
7DB8: 52 01    MOV   A,[X+1]            (0384)    mov   A, [X+wARG_BlockId+1]            ; set block ID to be 128 blocks by N Banks
7DBA: 6A       RLC   A                  (0385)    rlc   A
7DBB: 52 00    MOV   A,[X+0]            (0386)    mov   A, [X+wARG_BlockId]
7DBD: 6A       RLC   A                  (0387)    rlc   A
7DBE: 71 10    OR    F,0x10             
                                        (0388)    M8C_SetBank1
7DC0: 60 FA    MOV   REG[0xFA],A        (0389)    mov   reg[bSSC_FLASH_BlockID_BANK], A  ; set the bank of the blockID
7DC2: 70 EF    AND   F,0xEF             
                                        (0390)    M8C_SetBank0
7DC4: 08       PUSH  A                  (0391)    push  A
7DC5: 52 01    MOV   A,[X+1]            (0392)    mov   A, [X+wARG_BlockId+1]
7DC7: 21 7F    AND   A,0x7F             (0393)    and   A, 0x7F
7DC9: 53 FA    MOV   [0xFA],A           (0394)    mov   [bSSC_WRITE_BlockId], A          ; set the block-within-Bank-ID
7DCB: 08       PUSH  A                  (0395)    push  A
                                        (0396) 
7DCC: 52 05    MOV   A,[X+5]            (0397)    mov   A, [X+bDATA_PWErase]             ; set the pulse width
7DCE: 53 FC    MOV   [0xFC],A           (0398)    mov   [bSSC_WRITE_PulseWidth], A
7DD0: 55 FE 56 MOV   [0xFE],0x56        (0399)    mov   [bSSC_WRITE_Delay], bSSC_WRITE_DELAY   ; load the sequence delay count
                                        (0400)    ; Check the state variable - are we supposed to be here?
7DD3: 51 FD    MOV   A,[0xFD]           (0401)    mov   A, [bSSC_WRITE_State]
7DD5: 39 04    CMP   A,0x4              (0402)    cmp   A, STATE_ERASE_BLOCK
7DD7: B0 77    JNZ   0x7E4F             (0403)    jnz   bFlashWriteStateError
7DD9: 08       PUSH  A                  (0404)    push  A                                ; save the State variable
7DDA: 10       PUSH  X                  (0405)    push  X
7DDB: 4F       MOV   X,SP               
7DDC: 5B       MOV   A,X                
7DDD: 01 03    ADD   A,0x3              
7DDF: 53 F9    MOV   [0xF9],A           
7DE1: 55 F8 3A MOV   [0xF8],0x3A        
7DE4: 50 03    MOV   A,0x3              
7DE6: 00       SWI                      
                                        (0406) 
                                        (0407) IF	(TOOLCHAIN & HITECH)
                                        (0408) ELSE
                                        (0409) 	.nocc_start
                                        (0410) ENDIF
                                        (0411) 
                                        (0412) _FlashBlockLocal1:
                                        (0413)    SSC_Action FLASH_ERASE                 ; Erase the specified block
                                        (0414) 
                                        (0415) IF	(TOOLCHAIN & HITECH)
                                        (0416) ELSE
                                        (0417) 	.nocc_end
                                        (0418) ENDIF
                                        (0419) 
7DE7: 20       POP   X                  (0420)    pop   X
7DE8: 18       POP   A                  (0421)    pop   A                                ; restore the State variable
7DE9: 53 FD    MOV   [0xFD],A           (0422)    mov   [bSSC_WRITE_State], A
                                        (0423)    ; Check the return code for success
7DEB: 3C F8 00 CMP   [0xF8],0x0         (0424)    cmp   [bSSC_ResultCode], bSSC_SUCCESS
7DEE: A0 0B    JZ    0x7DFA             (0425)    jz    WriteBlock
                                        (0426)    ; Erase operation failed!
                                        (0427)    ; Need to set the result code, restore the clock, and then exit!
7DF0: 55 FF 00 MOV   [0xFF],0x0         (0428)    mov   [bSSC_WRITE_ResultCode], bSSC_WRITE_FAIL
7DF3: 55 FD 10 MOV   [0xFD],0x10        (0429)    mov   [bSSC_WRITE_State], STATE_RESTORE_CLOCK
7DF6: 38 FE    ADD   SP,0xFE            (0430)    add   SP, -2                           ; retire the bank and block #s
7DF8: 80 41    JMP   0x7E3A             (0431)    jmp   RestoreClock
                                        (0432) 
                                        (0433) ; Step 4 - Program the flash
                                        (0434) WriteBlock:
                                        (0435)    ; Update the state variable
7DFA: 65 FD    ASL   [0xFD]             (0436)    asl   [bSSC_WRITE_State]
                                        (0437)    ; State - Write Block
                                        (0438) 
7DFC: 18       POP   A                  (0439)    pop   A                                ; load WRITE opeation parameters
7DFD: 53 FA    MOV   [0xFA],A           (0440)    mov   [bSSC_WRITE_BlockId], A          ; set the LSB of the blockID
7DFF: 18       POP   A                  (0441)    pop   A
7E00: 71 10    OR    F,0x10             
                                        (0442)    M8C_SetBank1
7E02: 60 FA    MOV   REG[0xFA],A        (0443)    mov   reg[bSSC_FLASH_BlockID_BANK], A  ; set the bank of the blockID
7E04: 70 EF    AND   F,0xEF             
                                        (0444)    M8C_SetBank0
                                        (0445) 
7E06: 52 03    MOV   A,[X+3]            (0446)    mov   A, [X+pARG_FlashBuffer+1]        ; set the LSB of the RAM buffer ptr
7E08: 53 FB    MOV   [0xFB],A           (0447)    mov   [pSSC_WRITE_FlashBuffer], A
7E0A: 52 02    MOV   A,[X+2]            (0448)    mov   A, [X+pARG_FlashBuffer]          ; set the MSB of the RAM buffer ptr
7E0C: 60 D4    MOV   REG[0xD4],A        (0449)    mov   reg[MVR_PP], A
                                        (0450) 
                                        (0451) 
7E0E: 52 06    MOV   A,[X+6]            (0452)    mov   A, [X+bDATA_PWProgram]
7E10: 53 FC    MOV   [0xFC],A           (0453)    mov   [bSSC_WRITE_PulseWidth], A
7E12: 55 FE 56 MOV   [0xFE],0x56        (0454)    mov   [bSSC_WRITE_Delay], bSSC_WRITE_DELAY   ; load the sequence delay count
                                        (0455)    ; Check the state variable - are we supposed to be here?
7E15: 51 FD    MOV   A,[0xFD]           (0456)    mov   A, [bSSC_WRITE_State]
7E17: 39 08    CMP   A,0x8              (0457)    cmp   A, STATE_WRITE_BLOCK
7E19: B0 35    JNZ   0x7E4F             (0458)    jnz   bFlashWriteStateError
7E1B: 08       PUSH  A                  (0459)    push  A                                ; save the State variable
7E1C: 10       PUSH  X                  (0460)    push  X
7E1D: 4F       MOV   X,SP               
7E1E: 5B       MOV   A,X                
7E1F: 01 03    ADD   A,0x3              
7E21: 53 F9    MOV   [0xF9],A           
7E23: 55 F8 3A MOV   [0xF8],0x3A        
7E26: 50 02    MOV   A,0x2              
7E28: 00       SWI                      
                                        (0461) 
                                        (0462) IF	(TOOLCHAIN & HITECH)
                                        (0463) ELSE
                                        (0464) 	.nocc_start
                                        (0465) ENDIF
                                        (0466) 
                                        (0467) _FlashBlockLocal2:
                                        (0468)    SSC_Action FLASH_WRITE                 ; Program the flash
                                        (0469) 
                                        (0470) IF	(TOOLCHAIN & HITECH)
                                        (0471) ELSE
                                        (0472) 	.nocc_end
                                        (0473) ENDIF
                                        (0474) 
7E29: 20       POP   X                  (0475)    pop   X
7E2A: 18       POP   A                  (0476)    pop   A                                ; restore the state variable
7E2B: 53 FD    MOV   [0xFD],A           (0477)    mov   [bSSC_WRITE_State], A
                                        (0478)    ; Set the return code
7E2D: 55 FF 01 MOV   [0xFF],0x1         (0479)    mov   [bSSC_WRITE_ResultCode], bSSC_WRITE_SUCCESS
7E30: 3C F8 00 CMP   [0xF8],0x0         (0480)    cmp   [bSSC_ResultCode], bSSC_SUCCESS
7E33: A0 04    JZ    0x7E38             (0481)    jz    NextState
                                        (0482)    ; Write operation failed!
                                        (0483)    ; Need to set the result code, restore the clock, and then exit!
7E35: 55 FF 00 MOV   [0xFF],0x0         (0484)    mov   [bSSC_WRITE_ResultCode], bSSC_WRITE_FAIL
                                        (0485) 
                                        (0486) ; Step 5 - restore the original CPU rate
                                        (0487) NextState:
7E38: 65 FD    ASL   [0xFD]             (0488)    asl   [bSSC_WRITE_State]               ; update the state variable
                                        (0489)    ; Check the state variable - are we supposed to be here?
                                        (0490) RestoreClock:
7E3A: 3C FD 10 CMP   [0xFD],0x10        (0491)    cmp   [bSSC_WRITE_State], STATE_RESTORE_CLOCK
7E3D: B0 11    JNZ   0x7E4F             (0492)    jnz   bFlashWriteStateError
                                        (0493) 
                                        (0494)    ; State - Restore Clock
7E3F: 18       POP   A                  (0495)    pop   A
7E40: 71 10    OR    F,0x10             
                                        (0496)    M8C_SetBank1
7E42: 60 E0    MOV   REG[0xE0],A        (0497)    mov   reg[OSC_CR0], A                  ; Restore org CPU rate
7E44: 70 EF    AND   F,0xEF             
                                        (0498)    M8C_SetBank0                           ; Switch back to Bank 0
7E46: 65 FD    ASL   [0xFD]             (0499)    asl   [bSSC_WRITE_State]               ; update the state variable
                                        (0500) 
                                        (0501) ; Step 6 - Compute the return result code
7E48: 51 FF    MOV   A,[0xFF]           (0502)    mov   A, [bSSC_WRITE_ResultCode]
                                        (0503) 
                                        (0504) bFlashWriteBlockEnd:
                                        (0505) ; check the state variable for proper exit -
7E4A: 3C FD 20 CMP   [0xFD],0x20        (0506)    cmp   [bSSC_WRITE_State], STATE_DONE
7E4D: A0 04    JZ    0x7E52             (0507)    jz    bFlashWriteExit
                                        (0508) 
                                        (0509) ; if we arrived here, it means that the flashWrite API was randomly entered!!!
                                        (0510) bFlashWriteStateError:
7E4F: 30       HALT                     (0511)    halt
7E50: 8F FE    JMP   0x7E4F             (0512)    jmp   bFlashWriteStateError
7E52: 70 3F    AND   F,0x3F             
7E54: 71 C0    OR    F,0xC0             
7E56: 62 D0 00 MOV   REG[0xD0],0x0      
7E59: 62 D5 00 MOV   REG[0xD5],0x0      
7E5C: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0513) 
                                        (0514) bFlashWriteExit:
                                        (0515)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0516) 
                                        (0517)    ; default critical paging registers to PAGE 0 to support both LMM and SMM
                                        (0518)    RAM_SETPAGE_CUR 0                      ; cur_ptr page 
                                        (0519)    RAM_SETPAGE_MVW 0                      ; MW_ptr page 
                                        (0520)    RAM_SETPAGE_MVR 0                      ; Mr_ptr page
                                        (0521) 
                                        (0522) ; return with a RETI to preserve the last paging mode - SMM or LMM
7E5F: 7E       RETI                     (0523)    reti
                                        (0524) 
                                        (0525) ; Put halt here in case we jump inadvertently
7E60: 30       HALT                     (0526)    halt
7E61: 30       HALT                     (0527)    halt
7E62: 30       HALT                     (0528)    halt
                                        (0529) 
                                        (0530) ;-----------------------------------------------------------------------------
                                        (0531) ;  FUNCTION NAME:    ComputePulseWidth
                                        (0532) ;
                                        (0533) ;  DESCRIPTION:
                                        (0534) ;     Computes the Block Erase and Block Program pulse width counts for the
                                        (0535) ;     Flash Erase and Flash Program supervisory calls.
                                        (0536) ;
                                        (0537) ;     This routine gets its data from the FlashWriteBlock data structure
                                        (0538) ;     and saves the return data in the same structure.
                                        (0539) ;
                                        (0540) ;     First, the Temperature data table is accessed via the Table Read SSC
                                        (0541) ;     function.  Then the Erase  and Program pulse width counts are computed.
                                        (0542) ;
                                        (0543) ;     Temperature table gives the slope, Y intercept, and Erase to Program pulse
                                        (0544) ;     width converion.  Two equations are given - temperatures below 0 and
                                        (0545) ;     temperatures above 0. Data is scaled to fit within specified byte range.
                                        (0546) ;
                                        (0547) ;        PW(erase) = B - M*T*2/256 and PW(program)= PW(erase)*Multiplier/64
                                        (0548) ;
                                        (0549) ;     ADJUSTMENT FOR SLIMO:
                                        (0550) ;     --------------------
                                        (0551) ;     After calculation of both the PW(erase) and PW(Program), the SLIMO bit
                                        (0552) ;     is detected. If the SLIMO bit is enabled then both programming pulses are
                                        (0553) ;     divided by TWO and incremented by one for roundoff.  This is due to the fact
                                        (0554) ;     that the CPU clock will be set for 6MHz instead of 12MHz which means that the
                                        (0555) ;     SSC EraseBlk and WriteBlk operation will take twice as long.
                                        (0556) ;
                                        (0557) ;  ARGUMENTS:
                                        (0558) ;     X points to bFlashWriteBlock calling structure.
                                        (0559) ;
                                        (0560) ;  RETURNS:
                                        (0561) ;     BYTE  bResult - return in Accumulator
                                        (0562) ;           0 = valid
                                        (0563) ;           1 = invalid revision
                                        (0564) ;
                                        (0565) ;     Erase and Program pulse widths are returned in bFlashWriteBlock calling
                                        (0566) ;     structure.
                                        (0567) ;
                                        (0568) ;  SIDE EFFECTS:
                                        (0569) ;     none.
                                        (0570) ;
                                        (0571) ;  REQUIREMENTS:
                                        (0572) ;
                                        (0573) ;     1) The calculated erase pulse width is always < 128 (does not overflow 7 bits)
                                        (0574) ;     2) The calculated write pulse width is always < 256 (does not overflow 8 bits)
                                        (0575) ;     3) If SLIMO is enabled, then this algorithm assumes the CPU clock will be set
                                        (0576) ;        for 6MHz and NOT 12MHz!
                                        (0577) ;
                                        (0578) ;     These requirements MUST be guaranteed during device calibration.
                                        (0579) ;     They are not checked.  If they are not met, the pulse width calculation will fail.
                                        (0580) ;
                                        (0581) ;  PROCEDURE:
                                        (0582) ;     1) Get the flash programming temperature table
                                        (0583) ;     2) Check the table revision number
                                        (0584) ;     3) Select the correct data set, based on temperature
                                        (0585) ;     4) Compute the Erase Pulsewidth count
                                        (0586) ;     5) Compute the Program Pulsewidth count
                                        (0587) ;     6) Save the result data
                                        (0588) ;     7) Adjust for SLIMO
                                        (0589) ;
                                        (0590) ;-----------------------------------------------------------------------------
                                        (0591) bComputePulseWidth:
                                        (0592) 
                                        (0593)    ; 1) Get the flash programming temperature table
7E63: 55 FA 03 MOV   [0xFA],0x3         (0594)    mov   [bSSC_TABLE_TableId], TEMPERATURE_TABLE_ID
7E66: 62 D5 00 MOV   REG[0xD5],0x0      
7E69: 71 10    OR    F,0x10             
                                        (0595)    RAM_SETPAGE_MVW 0                      ; set table WRITE page to 0
                                        (0596)    M8C_SetBank1
7E6B: 62 FA 00 MOV   REG[0xFA],0x0      (0597)    mov   reg[bSSC_FLASH_BlockID_BANK], 0  ; set the SSC operation page to 0
7E6E: 70 EF    AND   F,0xEF             
                                        (0598)    M8C_SetBank0
                                        (0599) 
                                        (0600)    ; Check the State
7E70: 51 FD    MOV   A,[0xFD]           (0601)    mov   A, [bSSC_WRITE_State]
7E72: 39 02    CMP   A,0x2              (0602)    cmp   A, STATE_CALCULATE_PW
7E74: BF DA    JNZ   0x7E4F             (0603)    jnz   bFlashWriteStateError
7E76: 08       PUSH  A                  (0604)    push  A                                ; save the State variable
7E77: 10       PUSH  X                  (0605)    push  X
7E78: 4F       MOV   X,SP               
7E79: 5B       MOV   A,X                
7E7A: 01 03    ADD   A,0x3              
7E7C: 53 F9    MOV   [0xF9],A           
7E7E: 55 F8 3A MOV   [0xF8],0x3A        
7E81: 50 06    MOV   A,0x6              
7E83: 00       SWI                      
                                        (0606) 
                                        (0607) IF	(TOOLCHAIN & HITECH)
                                        (0608) ELSE
                                        (0609) 	.nocc_start
                                        (0610) ENDIF
                                        (0611) 
                                        (0612) _FlashBlockLocal3:
                                        (0613)    SSC_Action  FLASH_TEMP_TABLE_LOOKUP
                                        (0614) 
                                        (0615) IF	(TOOLCHAIN & HITECH)
                                        (0616) ELSE
                                        (0617) 	.nocc_end
                                        (0618) ENDIF
                                        (0619) 
7E84: 20       POP   X                  (0620)    pop   X
                                        (0621) 
                                        (0622)    ; 2) Check table revision
7E85: 3C FF 01 CMP   [0xFF],0x1         (0623)    cmp   [bTEMP_TempTableRevision], VALID_TABLE_REVISION
7E88: B0 85    JNZ   0x7F0E             (0624)    jnz   ComputePulseWidthTableError      ; jump if revision is out of date!
                                        (0625) 
                                        (0626)    ; 3) Select the correct data set, based on temperature
7E8A: 10       PUSH  X                  (0627)    push  X                                ; save the X pointer
7E8B: 5D D3    MOV   A,REG[0xD3]        
7E8D: 08       PUSH  A                  
                                        (0628) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0629)    REG_PRESERVE  IDX_PP                   ; save the X pointer page
                                        (0630) ENDIF
7E8E: 52 04    MOV   A,[X+4]            (0631)    mov   A, [X+cARG_Temperature]          ; load temperature into the MULTIPLIER
7E90: 60 E8    MOV   REG[0xE8],A        (0632)    mov   REG[MUL0_X], A
7E92: 21 80    AND   A,0x80             (0633)    and   A, 80h                           ; Test for sign of temperature
7E94: B0 09    JNZ   0x7E9E             (0634)    jnz   BelowZero
                                        (0635) 
                                        (0636) AboveZero:                                ; Positive temperature
7E96: 51 FD    MOV   A,[0xFD]           (0637)    mov   A, [sTEMP_LineEquationAboveZero + bTEMP_ProgMultOffset]
7E98: 54 07    MOV   [X+7],A            (0638)    mov   [X+bDATA_PWMultiplier], A        ; Save the multiplier for later use
7E9A: 57 FB    MOV   X,0xFB             (0639)    mov   X, sTEMP_LineEquationAboveZero   ; X pts to Temp table above zero
7E9C: 80 07    JMP   0x7EA4             (0640)    jmp   ComputeData
                                        (0641) 
                                        (0642) BelowZero:                                ; Negative temperature
7E9E: 51 FA    MOV   A,[0xFA]           (0643)    mov   A, [sTEMP_LineEquationBelowZero + bTEMP_ProgMultOffset]
7EA0: 54 07    MOV   [X+7],A            (0644)    mov   [X+bDATA_PWMultiplier], A        ; Save the multiplier for later use
7EA2: 57 F8    MOV   X,0xF8             (0645)    mov   X, sTEMP_LineEquationBelowZero   ; X pts to Temp table data below zero
7EA4: 62 D3 00 MOV   REG[0xD3],0x0      
                                        (0646) 
                                        (0647)    ; 4) Compute the Erase PulseWidth count => PW(e) = B - M*T*2/256
                                        (0648) ComputeData:
                                        (0649)    RAM_SETPAGE_IDX  0                     ; set the X pointer page to pt to zero page
                                        (0650)                                           ; where the temp table data is located.
7EA7: 52 00    MOV   A,[X+0]            (0651)    mov   A, [X+cTEMP_SlopeOffset]         ; compute M*T
7EA9: 60 E9    MOV   REG[0xE9],A        (0652)    mov   REG[MUL0_Y], A
7EAB: 5D EB    MOV   A,REG[0xEB]        (0653)    mov   A, REG[MUL0_DL]                   ; compute M*T*2
7EAD: 64       ASL   A                  (0654)    asl   A
7EAE: 5D EA    MOV   A,REG[0xEA]        (0655)    mov   A, REG[MUL0_DH]
7EB0: 6A       RLC   A                  (0656)    rlc   A                                ; A = M*T*2/256
7EB1: 73       CPL   A                  (0657)    cpl   A                                ; 2's complement the data - complement and then increment
7EB2: 74       INC   A                  (0658)    inc   A                                ; A = -(M*T*2/256)
7EB3: 03 01    ADD   A,[X+1]            (0659)    add   A, [X+cTEMP_InterceptOffset]     ; Add it to B to compute PW(e) => B - (M*T*2/256) => ERASE PulseWidth
7EB5: 53 FE    MOV   [0xFE],A           (0660)    mov   [bTEMP_PulseWidthErase], A       ; Save the Erase Pulse width in temp area
7EB7: 47 FE 80 TST   [0xFE],0x80        (0661)    tst	 [bTEMP_PulseWidthErase], 80h	  ; check for PW(e) > 127
7EBA: A0 05    JZ    0x7EC0             (0662)    jz	 ComputeProgPW
7EBC: 50 7F    MOV   A,0x7F             (0663)    mov	 A, 7Fh							  
7EBE: 53 FE    MOV   [0xFE],A           (0664)    mov	 [bTEMP_PulseWidthErase], A		  ; assign PW(e) = 127, if it's greater than 127
                                        (0665) 
                                        (0666) ComputeProgPW:
                                        (0667)    ; 5) Compute the Program PulseWidth      PW(program) = PW(erase) * ProgramMultiplier / 64
                                        (0668)    ;and   A, 7Fh                           ; Mac is signed - Erase pulse width MUST always be < 128
7EC0: 60 E8    MOV   REG[0xE8],A        (0669)    mov   REG[MUL0_X], A                    ; compute PW(e) * ProgMult
7EC2: 52 02    MOV   A,[X+2]            (0670)    mov   A, [X+bTEMP_ProgMultOffset]      ; Mac is signed - First multiply by high 7 bits of ProgMult
7EC4: 67       ASR   A                  (0671)    asr   A                                ; shift high 7 bits down to low 7 bits (divide by 2)
7EC5: 21 7F    AND   A,0x7F             (0672)    and   A, 0x7f                          ; zero out high bit to make it an unsigned divide by 2
7EC7: 60 E9    MOV   REG[0xE9],A        (0673)    mov   REG[MUL0_Y], A                    ; Do the 7 bit x 7 bit hardware multiply
                                        (0674) .mult7x7done:
7EC9: 5D EA    MOV   A,REG[0xEA]        (0675)    mov   A, REG[MUL0_DH]                   ; Load 16 bit result into (PulseWidthProg, A)
7ECB: 53 FF    MOV   [0xFF],A           (0676)    mov   [bTEMP_PulseWidthProgram], A
7ECD: 5D EB    MOV   A,REG[0xEB]        (0677)    mov   A, REG[MUL0_DL]
7ECF: 64       ASL   A                  (0678)    asl   A                                ; Shift left to compensate for divide by 2 above
7ED0: 6B FF    RLC   [0xFF]             (0679)    rlc   [bTEMP_PulseWidthProgram]
                                        (0680) .shift7x7done:
7ED2: 48 02 01 TST   [X+2],0x1          (0681)    tst   [X+bTEMP_ProgMultOffset], 0x01   ; If low bit of ProgMult was set (lost during divide by 2),
7ED5: A0 06    JZ    0x7EDC             (0682)    jz    .mult7x8done                     ; add 1 * PulseWidthErase to product
7ED7: 02 FE    ADD   A,[0xFE]           (0683)    add   A, [bTEMP_PulseWidthErase]
7ED9: 0E FF 00 ADC   [0xFF],0x0         (0684)    adc   [bTEMP_PulseWidthProgram], 0
                                        (0685) .mult7x8done:                             ; PW(e) * ProgMult is in (PulseWidthProg, A)
7EDC: 64       ASL   A                  (0686)    asl   A                                ; shift left twice to get
7EDD: 6B FF    RLC   [0xFF]             (0687)    rlc   [bTEMP_PulseWidthProgram]        ; 4 * PW(e) * ProgMult in (PulseWidthProg, A)
7EDF: C0 08    JC    0x7EE8             (0688)    jc    OverFlowDectect				  ; if carry=1 then there's overflow
7EE1: 64       ASL   A                  (0689)    asl   A                                ; The product MUST be < 2**14 for this to work.
7EE2: 6B FF    RLC   [0xFF]             (0690)    rlc   [bTEMP_PulseWidthProgram]        ; PW(p) = PW(e) * ProgMult / 64
7EE4: C0 03    JC    0x7EE8             (0691)    jc    OverFlowDectect				  ; if carry=1 then there's overflow
7EE6: 80 04    JMP   0x7EEB             (0692)    jmp	 SaveResultData
                                        (0693) 										  
                                        (0694) OverFlowDectect:
7EE8: 55 FF FF MOV   [0xFF],0xFF        (0695)    mov   [bTEMP_PulseWidthProgram], 0xff                                 
7EEB: 18       POP   A                  
7EEC: 60 D3    MOV   REG[0xD3],A        
                                        (0696) 										  
                                        (0697)    ; 6) Save the result data
                                        (0698) SaveResultData:
                                        (0699) IF SYSTEM_LARGE_MEMORY_MODEL
                                        (0700)    REG_RESTORE IDX_PP                     ; restore the XPP to point to the PW Data
                                        (0701) ENDIF
7EEE: 51 FF    MOV   A,[0xFF]           (0702)    mov   A, [bTEMP_PulseWidthProgram]
7EF0: 20       POP   X                  (0703)    pop   X                                ; restore the X pointer
7EF1: 54 06    MOV   [X+6],A            (0704)    mov   [X+bDATA_PWProgram], A           ; Save Program pulse width in BlockWrite calling frame
7EF3: 51 FE    MOV   A,[0xFE]           (0705)    mov   A, [bTEMP_PulseWidthErase]       ; Save Erase pulse width in BlockWrite calling frame
7EF5: 54 05    MOV   [X+5],A            (0706)    mov   [X+bDATA_PWErase], A
                                        (0707) 
                                        (0708)    ; 7) Adjust the Pulse Width for SLIMO setting
                                        (0709) AdjustForSLIMO:
7EF7: 49 FE 10 TST   REG[0xFE],0x10     (0710)    tst   reg[CPU_SCR1], CPU_SCR1_SLIMO    ; Check state of SLIMO
7EFA: A0 09    JZ    0x7F04             (0711)    jz    ComputePulseWidthEnd             ; if Z=0 then SLIMO NOT enabled - do nothing
                                        (0712) 
                                        (0713)    ;SLIMO is enabled - divide the pulsewidths by two and add one for round-off error
7EFC: 69 06    ASR   [X+6]              (0714)    asr   [X+bDATA_PWProgram]
7EFE: 77 06    INC   [X+6]              (0715)    inc   [X+bDATA_PWProgram]
7F00: 69 05    ASR   [X+5]              (0716)    asr   [X+bDATA_PWErase]
7F02: 77 05    INC   [X+5]              (0717)    inc   [X+bDATA_PWErase]
                                        (0718) 
                                        (0719) ComputePulseWidthEnd:                     ; NORMAL Termination
7F04: 18       POP   A                  (0720)    pop   A                                ;  restore the STATE
7F05: 39 02    CMP   A,0x2              (0721)    cmp   A, STATE_CALCULATE_PW            ;  make sure we are supposed to be here
7F07: BF 47    JNZ   0x7E4F             (0722)    jnz   bFlashWriteStateError
7F09: 53 FD    MOV   [0xFD],A           (0723)    mov   [bSSC_WRITE_State], A            ;  restore the state variable
7F0B: 50 00    MOV   A,0x0              (0724)    mov   A, bSSC_SUCCESS                  ; load return value with success!
7F0D: 7F       RET                      (0725)    ret
                                        (0726) 
                                        (0727) ComputePulseWidthTableError:              ; TABLE Error Termination
7F0E: 18       POP   A                  (0728)    pop   A                                ;  restore the STATE
7F0F: 39 02    CMP   A,0x2              (0729)    cmp   A, STATE_CALCULATE_PW            ;  make sure we are supposed to be here
7F11: BF 3D    JNZ   0x7E4F             (0730)    jnz   bFlashWriteStateError
7F13: 53 FD    MOV   [0xFD],A           (0731)    mov   [bSSC_WRITE_State], A            ;  restore the state variable
7F15: 50 01    MOV   A,0x1              (0732)    mov   A, bSSC_FAIL                     ; load return value with Failure!
7F17: 7F       RET                      (0733)    ret
7F18: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0734) 
                                        (0735) .ENDSECTION
                                        (0736) 
                                        (0737) ;------------------------------------------------------------------------------
                                        (0738) ;   FUNCTION NAME: FlashReadBlock
                                        (0739) ;
                                        (0740) ;   DESCRIPTION:
                                        (0741) ;   Reads a specified flash block to a buffer in RAM.
                                        (0742) ;
                                        (0743) ;   ARGUMENTS:
                                        (0744) ;   A,X -> FLASH_READ_STRUCT
                                        (0745) ;
                                        (0746) ;   RETURNS:
                                        (0747) ;   Data read is returned at specified pFlashBuffer.
                                        (0748) ;
                                        (0749) ;   SIDE EFFECTS:
                                        (0750) ;   Uses SSC storage at FBh and FDh
                                        (0751) ;
                                        (0752) ;   PROCEDURE:
                                        (0753) ;   BlockID is converted to absolute address and then ROMX command is used
                                        (0754) ;   to read the data from flash into the specified buffer.
                                        (0755) ;
                                        (0756) ;------------------------------------------------------------------------------
                                        (0757) .SECTION
                                        (0758)  FlashReadBlock:
                                        (0759) _FlashReadBlock:
                                        (0760) 
                                        (0761)    ; Preserve the SMM or LMM paging mode
                                        (0762)    RAM_SETPAGE_CUR  0
7F1B: 53 F8    MOV   [0xF8],A           (0763)    mov   [bTEMP_SPACE], A     ; temporarily store the MSB of the WriteBlock structure
7F1D: 5D F7    MOV   A,REG[0xF7]        (0764)    mov   A, reg[CPU_F]        ; grab the current CPU flag register and save on stack
7F1F: 08       PUSH  A                  (0765)    push  A
7F20: 21 C0    AND   A,0xC0             (0766)    and   a, c0h
7F22: B0 07    JNZ   0x7F2A             (0767)    jnz   YesPaging
                                        (0768)    ;  Enforce MSB to 0 when not in a paging mode
7F24: 56 02 00 MOV   [X+2],0x0          (0769)    mov   [X+pARG_FlashBuffer], 0
7F27: 55 F8 00 MOV   [0xF8],0x0         (0770)    mov   [bTEMP_SPACE], 0
                                        (0771) YesPaging:
                                        (0772) 
7F2A: 51 F8    MOV   A,[0xF8]           (0773)    mov   A, [bTEMP_SPACE]     ; restore the MSB of the WriteBlock structure
7F2C: 70 BF    AND   F,0xBF             
7F2E: 60 D3    MOV   REG[0xD3],A        
                                        (0774) 
                                        (0775)    ; Since the SSC operations all reference page 0, save and set the current ptr
                                        (0776)    ; to page 0 and the X_ptr to track the stack page.
                                        (0777)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0778)    RAM_SETPAGE_IDX  A
                                        (0779) 
                                        (0780)    ; mov some args to SSC storage
                                        (0781) 
7F30: 52 03    MOV   A,[X+3]            (0782)    mov   A, [X+pARG_FlashBuffer+1]    ; get pointer - LSB
7F32: 53 FB    MOV   [0xFB],A           (0783)    mov   [pSSC_READ_FlashBuffer],A    ; use SSC storage area
7F34: 52 02    MOV   A,[X+2]            (0784)    mov   A, [X+pARG_FlashBuffer]      ; get pointer - MSB
7F36: 60 D5    MOV   REG[0xD5],A        
                                        (0785)    RAM_SETPAGE_MVW A                  ; set the MSB in the MVI Write Pointer
7F38: 52 04    MOV   A,[X+4]            (0786)    mov   A, [X+wARG_ReadCount]        ; get count
7F3A: 74       INC   A                  (0787)    inc   A                            ; bump by one to account for testing
7F3B: 53 FD    MOV   [0xFD],A           (0788)    mov   [wSSC_READ_Counter],A        ; use SSC storage area
7F3D: 52 05    MOV   A,[X+5]            (0789)    mov   A, [X+wARG_ReadCount+1]
7F3F: 53 FE    MOV   [0xFE],A           (0790)    mov   [wSSC_READ_Counter+1],A
                                        (0791) 
                                        (0792)    ; Compute the absolute address of the flash block
                                        (0793) 
7F41: 52 01    MOV   A,[X+1]            (0794)    mov   A, [X+wARG_BlockId+1]        ; compute the LSB = wBlockId * 64
7F43: 64       ASL   A                  (0795)    asl   A
7F44: 6C 00    RLC   [X+0]              (0796)    rlc   [X+wARG_BlockId]
7F46: 64       ASL   A                  (0797)    asl   A
7F47: 6C 00    RLC   [X+0]              (0798)    rlc   [X+wARG_BlockId]
7F49: 64       ASL   A                  (0799)    asl   A
7F4A: 6C 00    RLC   [X+0]              (0800)    rlc   [X+wARG_BlockId]
7F4C: 64       ASL   A                  (0801)    asl   A
7F4D: 6C 00    RLC   [X+0]              (0802)    rlc   [X+wARG_BlockId]
7F4F: 64       ASL   A                  (0803)    asl   A
7F50: 6C 00    RLC   [X+0]              (0804)    rlc   [X+wARG_BlockId]
7F52: 64       ASL   A                  (0805)    asl   A
7F53: 6C 00    RLC   [X+0]              (0806)    rlc   [X+wARG_BlockId]
                                        (0807) 
7F55: 08       PUSH  A                  (0808)    push  A                            ; save LSB
7F56: 52 00    MOV   A,[X+0]            (0809)    mov   A, [X+wARG_BlockId]          ; mov MSB into A
7F58: 20       POP   X                  (0810)    pop   X                            ; put LSB into X
                                        (0811) 
                                        (0812)    ; Read the Flash
                                        (0813) ReadFlash:
7F59: 08       PUSH  A                  (0814)    push	 A                            ; save MSB
7F5A: 28       ROMX                     (0815)    romx                               ; Read the flash
7F5B: 3F FB    MVI   [0xFB],A           (0816)    mvi   [pSSC_READ_FlashBuffer], A   ; store the data in the RAM buffer
7F5D: 18       POP   A                  (0817)    pop   A                            ; restore MSB
7F5E: 75       INC   X                  (0818)    inc   X                            ; increment the LSB of the flash addr
7F5F: B0 02    JNZ   0x7F62             (0819)    jnz   TestCounter
7F61: 74       INC   A                  (0820)    inc   A
                                        (0821) TestCounter:
7F62: 7A FE    DEC   [0xFE]             (0822)    dec   [wSSC_READ_Counter+1]        ; decrement the byte counter
7F64: B0 05    JNZ   0x7F6A             (0823)    jnz   TestPageBoundary
7F66: 7A FD    DEC   [0xFD]             (0824)    dec   [wSSC_READ_Counter]
7F68: A0 0F    JZ    0x7F78             (0825)    jz    ReadFlashDone                ; if counter is zero - done!
                                        (0826) 
                                        (0827) TestPageBoundary:                     ; Test Buffer pointer to see if the page ptr
7F6A: 3C FB 00 CMP   [0xFB],0x0         (0828)    cmp   [pSSC_READ_FlashBuffer],0x00 ; has wrapped
7F6D: BF EB    JNZ   0x7F59             (0829)    jnz   ReadFlash
7F6F: 08       PUSH  A                  (0830)    push  A
7F70: 5D D5    MOV   A,REG[0xD5]        (0831)    mov   A, reg[MVW_PP]
7F72: 74       INC   A                  (0832)    inc   A
7F73: 60 D5    MOV   REG[0xD5],A        (0833)    mov   reg[MVW_PP], A
7F75: 18       POP   A                  (0834)    pop   A
7F76: 8F E2    JMP   0x7F59             (0835)    jmp   ReadFlash
7F78: 70 3F    AND   F,0x3F             
7F7A: 71 C0    OR    F,0xC0             
7F7C: 62 D0 00 MOV   REG[0xD0],0x0      
7F7F: 62 D5 00 MOV   REG[0xD5],0x0      
                                        (0836) 
                                        (0837)    ; Done reading the flash
                                        (0838) ReadFlashDone:
                                        (0839)    RAM_EPILOGUE RAM_USE_CLASS_3
                                        (0840) 
                                        (0841)    ; set the CUR and MVW page pointer to zero to support both LMM and SMM
                                        (0842)    RAM_SETPAGE_CUR 0                      ; cur_ptr page 
                                        (0843)    RAM_SETPAGE_MVW 0                      ; MW_ptr page 
                                        (0844) 
                                        (0845)    ;return using RETI to be sure the SMM or LMM paging mode is restored
7F82: 7E       RETI                     (0846)    reti
                                        (0847) 
                                        (0848) .ENDSECTION
                                        (0849) 
                                        (0850) ;---------------------
                                        (0851) ;  End of File
                                        (0852) ;-----------------------------------------------------------------------------------------------------


PSoC Designer Version: 5.0.972.0

Copyright (C) 1994 - 2011 ImageCraft Creations Inc.
ImageCraft, 2625 Middlefield Rd #685, Palo Alto, CA 94306
info@imagecraft.com, phone (650) 493-9326 FAX (866) 889-4834
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission
Version 7.05.00.
